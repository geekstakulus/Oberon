/*
* Copyright 2019 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Oberon parser/code model library.
*
* The following is the license that applies to this copy of the
* library. For a license to use the library under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "ObLuaGen.h"
#include <QDir>
#include <QtDebug>
#include <QCoreApplication>
#include <QDateTime>
#include <memory>
#include <typeinfo>
#include <stdio.h>
using namespace Ob;

static QSet<QByteArray> s_lkw;

static bool isLuaKeyword( const QByteArray& str )
{
    if( s_lkw.isEmpty() )
        s_lkw << "and" <<       "break" <<     "do" <<        "else" <<      "elseif"
              << "end" <<       "false" <<     "for" <<       "function" <<  "if"
              << "in" <<        "local" <<     "nil" <<       "not" <<       "or"
              << "repeat" <<    "return" <<    "then" <<      "true" <<      "until" <<     "while"
                 // built-in LuaJIT libraries
              << "math" << "bit" << "obnlj" << "module";
    return s_lkw.contains(str);
}

static bool startsWith2Underscores( const QByteArray& str )
{
    if( !str.startsWith("__") )
        return false;
    if( str.size() == 2 )
        return true;
    if( str[3] == '_' )
        return false;
    else
        return true;
}

static QByteArray luaStringEscape( QByteArray str )
{
    QByteArray out;
    out.reserve(str.size()*2);
    char buf[10];
    for( int i = 0; i < str.size(); i++ )
    {
        const quint8 c = quint8(str[i]);
        if( QChar::fromLatin1(str[i]).isPrint() && c != 255 )
        {
            switch( quint8(str[i]))
            {
            case '\\':
                out += "\\\\";
                break;
            case '"':
                out += "\\\"";
                break;
            default:
                out += str[i];
                break;
            }
        }else
        {
            switch( c )
            {
            case '\n':
                out += "\\n";
                break;
            case '\t':
                out += "\\t";
                break;
            case '\a':
                out += "\\a";
                break;
            case '\b':
                out += "\\b";
            case '\f':
                out += "\\f";
                break;
            case '\v':
                out += "\\v";
                break;
            case 0:
                out += "\\0";
                break;
            default:
                ::sprintf(buf,"\\%03d", c );
                out += buf;
                break;
            }
        }
    }
    return out;
}

static inline const CodeModel::Type* derefed( const CodeModel::Type* t )
{
    return ( t != 0 ? t->deref() : 0 );
}

static QByteArray quali( const SynTree* st )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_qualident );
    if( st->d_children.size() == 1 )
        return st->d_children.first()->d_tok.d_val;
    else
        return st->d_children.first()->d_tok.d_val + "." + st->d_children.last()->d_tok.d_val;
}

LuaGen::LuaGen(CodeModel* mdl):d_mdl(mdl),d_errs(0),d_curMod(0),d_suppressVar(false)
{
    Q_ASSERT( mdl != 0 );
    d_errs = mdl->getErrs();
}

bool Ob::LuaGen::emitModules(const QString& outdir, const QString& mod)
{
    QDir dir(outdir);
    if( !mod.isEmpty() )
    {
        dir.mkpath( mod );
        dir.cd( mod );
    }

    const int precount = d_errs->getErrCount();
    foreach( CodeModel::Module* m, d_mdl->getGlobalScope().d_mods )
    {
        if( m->d_def == 0 || m->d_isDef ) // no stubs, no definition files
            continue;
        qDebug() << "translating module" << m->d_name;
        const QByteArray lua = emitModule(m);
        if( !lua.isEmpty() )
        {
            QFile out( dir.absoluteFilePath( escape(m->d_name) + ".lua" ) );
            if( !out.open(QIODevice::WriteOnly) )
                d_errs->error(Errors::Generator,m->d_name, 0,0,QString("cannot open file '%1' for writing").arg(out.fileName()) );
            else
                out.write(lua);
        }
    }
    return precount == int(d_errs->getErrCount());
}

QByteArray LuaGen::emitModule(const CodeModel::Module* m)
{
    Q_ASSERT( m && m->d_def );

    d_curMod = m;

    QByteArray code;
    QTextStream out(&code,QIODevice::WriteOnly);

    out << "-- Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
            " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    int l = 0;

    d_thunkNames.clear();

    d_cmts.clear();
    if( m->d_def )
        d_cmts = d_mdl->getComments(m->d_def->d_tok.d_sourcePath);
    d_nextCmt = 0;

    out << "---------- MODULE " << m->d_name << " ----------" << endl;
    out << "local module = {}" << endl << endl;
    emitComment(m->d_def,out,l);

    CodeModel::Scope::Names imps;
    CodeModel::Scope::Names::const_iterator i;
    for( i = m->d_names.begin(); i != m->d_names.end(); ++i )
    {
        if( CodeModel::Module* m = dynamic_cast<CodeModel::Module*>( i.value() ) )
            imps.insert(i.key(),i.value());
    }
    out << "local obnlj = require 'obnlj'" << endl << endl;
    if( !imps.isEmpty() )
    {
        out << "----- IMPORT -----" << endl;
        for( i = imps.begin(); i != imps.end(); ++i )
        {
            emitComment(i.value()->d_def,out,l);
            out << "local " << escape(i.key()) << " = require '" << escape(i.value()->d_name) << "'" << endl;
        }
        out << endl;
    }

    emitDecls(m,out,l);

    if( !m->d_procs.isEmpty() )
        out << ws(l) << "----- PROC -----" << endl;
    foreach( const CodeModel::Procedure* v, m->d_procs )
    {
        emitProc(m,v,out,l);
    }
    if( !m->d_procs.isEmpty() )
        out << endl;

    if( !m->d_body.isEmpty() )
    {
        foreach( SynTree* stmnt, m->d_body )
            preprocVarParams(m, stmnt, out, l);
        out << ws(l) << "-- BEGIN" << endl;
    }
    emitStatementSeq(m, m->d_body, out,l);
//    if( !m->d_body.isEmpty() )
//        out << ws(l) << "-- END" << endl << endl;

    out << "return module" << endl;
    out << "---------- END MODULE " << m->d_name << " ----------" << endl;
    out.flush();
    return code;
}

QString LuaGen::ws(int level)
{
    return QString(level,QChar('\t'));
}

static void renderString( QTextStream& out, const SynTree* st )
{
    switch( st->d_tok.d_type )
    {
    case Tok_string:
        // we need obnlj.Str here because Lua __eq only works of lhs and rhs same type
        out << "obnlj.Str(\"" << luaStringEscape( st->d_tok.d_val.mid(1, st->d_tok.d_val.size() - 2 ) ) << "\")";
        break;
    case Tok_hexchar:
        //out << "obnlj.Str(\"" << luaStringEscape(
        //           QByteArray::fromHex( first->d_tok.d_val.left( first->d_tok.d_val.size() - 1 ) ) ) << "\")";
        out << "obnlj.Str(\"" << QString("\\%1").arg(
                   st->d_tok.d_val.left( st->d_tok.d_val.size() - 1 ).toUInt(0,16),3,10,QChar('0')
                   ).toUtf8() << "\")";
        break;
    case Tok_hexstring:
        // TODO: convert to \xxx form?
        out << "obnlj.Str(\"" << luaStringEscape(
                   QByteArray::fromHex(st->d_tok.d_val.mid(1, st->d_tok.d_val.size() - 2)) ) << "\")";
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

void LuaGen::emitFactor(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_factor && !st->d_children.isEmpty() );
    const SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_set:
        emitSet(ds,first,out, level);
        break;
    case SynTree::R_number:
        Q_ASSERT( !st->d_children.first()->d_children.isEmpty() );
        if( st->d_children.first()->d_children.first()->d_tok.d_val.endsWith('H') )
            out << "0x" << st->d_children.first()->d_children.first()->d_tok.d_val.left(
                       st->d_children.first()->d_children.first()->d_tok.d_val.size() - 1 );
        else
            out << st->d_children.first()->d_children.first()->d_tok.d_val;
        break;
    case Tok_TRUE:
        out << "true";
        break;
    case Tok_FALSE:
        out << "false";
        break;
    case Tok_NIL:
        out << "nil";
        break;
    case Tok_Lpar:
        out << "(";
        Q_ASSERT(st->d_children.size() == 3);
        emitExpression(ds,st->d_children[1],out,level);
        out << ")";
        break;
    case Tok_Tilde:
        out << "not (";
        Q_ASSERT(st->d_children.size() == 2 );
        emitFactor(ds,st->d_children[1], out, level );
        out << ")";
        break;
    case Tok_string:
    case Tok_hexchar:
    case Tok_hexstring:
        renderString(out, first );
        break;
    case SynTree::R_variableOrFunctionCall:
        emitDesigList(ds,d_mdl->derefDesignator( ds, first->d_children.first() ), false, out,level);
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

bool LuaGen::emitDesigList(const CodeModel::Unit* ds, const CodeModel::DesigOpList& dopl,
                                             bool procCall, QTextStream& out, int level)
{
    const CodeModel::Element* e = 0; ;
    if( dopl.size() == 2 && ( e = dynamic_cast<const CodeModel::Element*>( dopl.first().d_sym ) ) && e->isPredefProc() )
    {
        if( emitPredefProc( ds, dopl, out, level ) )
            return false;
    }

    bool printedSomething = false;
    for( int i = 0; i < dopl.size(); i++ )
    {
        if( printedSomething && dopl[i].d_op == CodeModel::IdentOp )
            out << ".";
        if( emitDesig(ds, i != 0 ? dopl[i-1].d_sym : 0, dopl[i], out, level ) )
        {
            const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>(dopl[i].d_sym);
            if( ( !d_suppressVar && dopl[i].d_sym != 0 && dopl[i].d_sym->d_var ) || // VAR param
                   ( i == 1 && e != 0 && e->d_kind == CodeModel::Element::Variable &&
                     dynamic_cast<const CodeModel::Module*>(dopl[i-1].d_sym) ) ) // extern variable
                out << "()";

            printedSomething = true;
        }
    }
    if( procCall && !dopl.isEmpty() && dopl.last().d_op != CodeModel::ProcedureOp )
    {
        bool isCallWithoutParams = false;
        if( const CodeModel::Element* el = dynamic_cast<const CodeModel::Element*>(dopl.last().d_sym) )
        {
            const CodeModel::Type* type = derefed(el->d_type);
            isCallWithoutParams = ( el->d_kind == CodeModel::Element::StubProc ) ||
                    ( type && type->d_kind == CodeModel::Type::ProcRef );
        }else if( dynamic_cast<const CodeModel::Procedure*>(dopl.last().d_sym) )
            isCallWithoutParams = true;
        else if( const CodeModel::Type* t = dynamic_cast<const CodeModel::Type*>(dopl.last().d_sym) )
            isCallWithoutParams = t->d_kind == CodeModel::Type::ProcRef;
        if( isCallWithoutParams )
        {
            out << "()";
            printedSomething = true;
        }
    }

    return printedSomething;
}

static int countPrintable( const CodeModel::DesigOpList& dopl )
{
    int res = 0;
    for( int i = 0; i < dopl.size(); i++ )
    {
        switch( dopl[i].d_op )
        {
        case CodeModel::IdentOp:
        case CodeModel::ProcedureOp:
        case CodeModel::ArrayOp:
            res++;
            break;
        default:
            break;
        }
    }
    return res;
}

void LuaGen::emitAssig(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st->d_tok.d_type == SynTree::R_assignment_ && st->d_children.size() == 3 );
    emitAssig( ds, st->d_children.first(), st->d_children.last(), out, level );
}

bool LuaGen::emitAssig(const CodeModel::Unit* ds, const SynTree* lhs, const SynTree* rhs, QTextStream& out, int level)
{
    if( rhs )
        out << ws(level);
    CodeModel::DesigOpList dopl = d_mdl->derefDesignator( ds, lhs );
    const int prints = countPrintable(dopl);
    d_suppressVar = prints == 1;
    emitDesigList(ds, dopl, false, out, level);
    d_suppressVar = false;
    // TODO: make a copy of value types, e.g. using {table.unpack(org)}
    bool thunk = false;
    const bool arrayOfChar = d_mdl->isArrayOfChar( dopl.last().d_sym );
    if( prints == 1 && dopl.first().d_op == CodeModel::IdentOp && dopl.first().d_sym->d_var )
    {
        thunk = true;
        if( arrayOfChar )
            out << "():assig( "; // ASSIG
        else
            out << "( true, ";
        if( rhs )
        {
            emitExpression(ds,rhs, out, level );
            out << " )";
        }
    }else
    {
        if( arrayOfChar )
        {
            out << ":assig( "; // ASSIG
            if( rhs == 0 )
                thunk = true; // so that caller closes rpar
        }else
            out << " = "; // ASSIG
        if( rhs )
        {
            emitExpression(ds,rhs, out, level );
            if( arrayOfChar )
                out << " )";
        }
    }
    if( rhs )
        out << endl;
    return thunk;
}

bool LuaGen::emitDesig(const CodeModel::Unit* ds, const CodeModel::NamedThing* prev,
                       const CodeModel::DesigOp& dop, QTextStream& out, int level)
{
    bool printedSomething = false;
    switch( dop.d_op )
    {
    case CodeModel::IdentOp:
        Q_ASSERT( dop.d_sym );
        Q_ASSERT( dop.d_arg->d_tok.d_type == Tok_ident );
        //out << escape(dop.d_sym->d_name);
        out << escape(dop.d_arg->d_tok.d_val); // sonst wird bei importierten Modulen deren Name statt der lokale name verwendet!
        printedSomething = true;
        break;
    case CodeModel::PointerOp:
        break;
    case CodeModel::TypeOp:
        break;
    case CodeModel::ProcedureOp:
        {
            Q_ASSERT( prev != 0 );
            const QList<CodeModel::Element*> params = prev->getParams();
            if( dop.d_arg && dop.d_arg->d_children.size() != params.size() )
            {
                d_errs->error(Errors::Semantics, dop.d_arg, tr("missmatch between formal and actual params") );
                break;
            }
            out << "(";
            if( dop.d_arg )
            {
                Q_ASSERT( dop.d_arg->d_tok.d_type == SynTree::R_ExpList );

                for( int j = 0; j < dop.d_arg->d_children.size(); j++ )
                {
                    if( j != 0 )
                        out << ", ";
                    emitActualParam(ds,dop.d_arg->d_children[j], params[j]->d_var, out, level );
                }
            }else if( !params.isEmpty() )
                d_errs->error(Errors::Semantics, params.first()->d_def, tr("missmatch between formal and actual params") );
            out << ")";
            printedSomething = true;
        }
        break;
    case CodeModel::ArrayOp:
        emitArrayOp( ds, dop.d_arg, out, level );
        printedSomething = true;
        break;
    default:
        break;
    }
    return printedSomething;
}

void LuaGen::emitTypeDecl(const CodeModel::Unit* ds, const CodeModel::Type* t, QTextStream& out, int level)
{
    Q_ASSERT( !t->d_name.isEmpty() );
    const CodeModel::Type* td = derefed(t);
    if( t->d_kind == CodeModel::Type::Record )
    {
        const QByteArray name = escape(t->d_name);
        out << ws(level) << "local " << name << " = "; // ASSIG
        if( t->d_type )
        {
            Q_ASSERT( t->d_type->d_kind == CodeModel::Type::TypeRef );
            out << "obnlj.instance( " << quali( t->d_type->d_st ) << " )" << endl;
        }else
            out << "{}" << endl;
        if( ds == d_curMod && t->d_public )
            out << "module" << "." << escape(t->d_name) << " = " << escape(t->d_name) << endl;

    }else if( t->d_kind == CodeModel::Type::TypeRef && td && td->d_kind == CodeModel::Type::Record )
    {
        out << ws(level) << "local " << escape(t->d_name) << " = " << quali(t->d_st) << endl; // ASSIG
        if( ds == d_curMod && t->d_public )
            out << "module" << "." << escape(t->d_name) << " = " << escape(t->d_name) << endl;
    }
    // else: es gibt keine Typendeklarationen für alle übrigen typen
}

void LuaGen::initMatrix( const CodeModel::Unit* ds, QTextStream& out, const QList<const CodeModel::Type*>& dims,
                         const QByteArray& name, int level, int i, const CodeModel::Type* rec )
{
    if( i >= ( dims.size() - 1 ) )
    {
        if( rec )
        {
            out << ws(level+i) << "for __" << i << "=1," << dims[i]->d_len << " do" << endl;
            out << ws(level+i+1) << "local ";
            initRecord(ds, out, rec, "rec", false, level+i+1, false );
            out << ws(level+i+1) << name;
            for( int j = 0; j <= i; j++ )
                out << "[__" << j << "]";
            out << " = rec" << endl; // ASSIG
            out << ws(level+i) << "end" << endl;
        }
        return;
    }
    out << ws(level+i) << "for __" << i << "=1," << dims[i]->d_len << " do" << endl;
    out << ws(level+i+1) << name;
    for( int j = 0; j <= i; j++ )
        out << "[__" << j << "]";

    if( derefed(dims[i+1]->d_type) == d_mdl->getGlobalScope().d_charType )
        out << " = obnlj.Str("; // ASSIG
    else
        out << " = obnlj.Arr("; // ASSIG
    out << dims[i+1]->d_len << ")" << endl;

    initMatrix(ds, out,dims,name,level, i+1, rec );
    out << ws(level+i) << "end" << endl;
}

void LuaGen::initRecord(const CodeModel::Unit* ds, QTextStream& out,
                        const CodeModel::Type* rec, const QByteArray& name, bool var, int level, bool label)
{
    out << name;
    if( var )
        out << "( true, ";
    else
        out << " = ";
    if( rec && rec->d_kind == CodeModel::Type::TypeRef )
    {
        // Named Type
        Q_ASSERT( rec->d_st && rec->d_st->d_tok.d_type == SynTree::R_qualident );
        out << "obnlj.instance(" << quali( rec->d_st ) << ")"; // ASSIG
    }else
    {
        Q_ASSERT( rec->d_kind == CodeModel::Type::Record );
        // anonymous type
        out << "{}"; // ASSIG
    }
    if( var )
        out << ")";
    if( label )
        out << " -- init RECORD " << name;
    out  << endl;
    if( rec == 0 )
        return;
    rec = derefed( rec );

    Q_ASSERT( rec->d_kind == CodeModel::Type::Record );

    QList<const CodeModel::Type*> super;
    super << rec;

    while( true )
    {
        // eval inheritance hierarchy
        rec = rec->d_type;
        if( rec )
        {
            Q_ASSERT( rec->d_kind == CodeModel::Type::TypeRef );
            CodeModel::Quali qq = d_mdl->derefQualident(ds, rec->d_st );
            rec = derefed(dynamic_cast<const CodeModel::Type*>( qq.second.first ) );
            if( rec && rec->d_kind == CodeModel::Type::Record )
                super.prepend(rec);
            else
                break;
        }else
            break;
    }

    for( int j = 0; j < super.size(); j++ )
    {
        // gehe von oben nach unten durch die Vererbungshierarchie und initialisiere die Members
        rec = super[j];
        CodeModel::Type::Vals::const_iterator i;
        for( i = rec->d_vals.begin(); i != rec->d_vals.end(); ++i )
        {
            const CodeModel::Type* t = i.value()->d_type;
            const CodeModel::Type* td = derefed( t );
            const QByteArray field = name + "." + i.key();
            if( td && td->d_kind == CodeModel::Type::Record )
            {
                out << ws(level);
                initRecord( ds, out, t, field, false, level, false );
            }else if( td && td->d_kind == CodeModel::Type::Array )
            {
                out << ws(level);
                initArray(ds, out, t, field, level, false);
            }
        }
    }
}

void LuaGen::initArray(const CodeModel::Unit* ds, QTextStream& out,
                       const CodeModel::Type* arr, const QByteArray& name, int level, bool label )
{
    const CodeModel::Type* t = arr;
    const CodeModel::Type* td = derefed(arr);
    QList<const CodeModel::Type*> dims;
    while( td && td->d_kind == CodeModel::Type::Array )
    {
        dims << td;
        t = td->d_type;
        td = derefed( td->d_type );
    }
    const CodeModel::Type* r = 0;
    if( td && td->d_kind == CodeModel::Type::Record )
        r = t;
    if( derefed(dims[0]->d_type) == d_mdl->getGlobalScope().d_charType )
        out << name << " = obnlj.Str("; // ASSIG
    else
        out << name << " = obnlj.Arr("; // ASSIG
    out  << dims[0]->d_len << ")";
    if( label )
        out << " -- init ARRAY " << name;
    out << endl;
    initMatrix( ds, out, dims, name, level, 0, r );
}

LuaGen::RecRef LuaGen::getRecRefFrom(const CodeModel::Unit* ds, SynTree* st)
{
    const CodeModel::Type* ptrRef = d_mdl->typeOfExpression(ds,st);
    const CodeModel::Type* ptr = 0;
    if( ptrRef )
        ptr = derefed(ptrRef);
    if( ptr == ptrRef )
        ptrRef = 0;
    if( ptr && ptr->d_kind == CodeModel::Type::Record )
        return qMakePair(ptrRef,ptr);
    const CodeModel::Type* rec = 0;
    const CodeModel::Type* recRef = 0;
    if( ptr )
        recRef = ptr->d_type;
    if( recRef )
        rec = derefed(recRef);
    if( recRef == rec )
        recRef = 0;
    return qMakePair( recRef, rec );
}

void LuaGen::emitVarDecl(const CodeModel::Unit* ds, const CodeModel::Element* v, QTextStream& out, int level)
{
    const CodeModel::Type* t = v->d_type;
    const CodeModel::Type* td = derefed(t);
    const QByteArray name = escape(v->d_name);
    out << ws(level) << "local ";
    if( td && td->d_kind == CodeModel::Type::Record )
    {
        initRecord( ds, out, t, name, false, level+1, true );
    }else if( td && td->d_kind == CodeModel::Type::Array )
    {
        initArray( ds, out, t, name, level+1, true );
    }else
        out << name << endl;

    if( ds == d_curMod && v->d_public )
        out << "module" << "." << name << " = function() return " << name << " end" << endl;
}

void LuaGen::emitProc(const CodeModel::Unit* ds, const CodeModel::Procedure* p, QTextStream& out, int level)
{
    const CodeModel::Module* m = p->getModule();
    Q_ASSERT( m != 0 );

    emitComment(p->d_def,out,0);

    out << ws(level) << "local function " << escape(p->d_name);

    out << "(";
    for( int i = 0; i < p->d_vals.size(); i++ )
    {
        if( i != 0 )
            out << ", ";
        const CodeModel::Element* par = p->d_vals[i];
        out << escape(par->d_name);
    }
    out << ")" << endl;

    emitDecls(p,out,level+1);

    if( !p->d_procs.isEmpty() )
        out << ws(level+1) << "----- PROC -----" << endl;
    foreach( const CodeModel::Procedure* v, p->d_procs )
    {
        emitProc(ds, v,out,level+1);
    }
    if( !m->d_procs.isEmpty() )
        out << endl;

#ifdef _DEBUG
    out << ws(level+1) << "obnlj.TRACE(\"" << escape(p->d_name) << "\"," << p->d_def->d_tok.d_lineNr << ")" << endl;
#endif
    if( !p->d_body.isEmpty() )
    {
        foreach( SynTree* stmnt, p->d_body )
            preprocVarParams(p, stmnt, out, level+1);
        out << ws(level+1) << "-- BEGIN" << endl;
    }
    emitStatementSeq(p,p->d_body,out,level+1);

    out << ws(level) << "end" << endl;

    if( ds == d_curMod && p->d_public )
        out << "module" << "." << escape(p->d_name) << " = " << escape(p->d_name) << endl;
    out << endl;
}

void LuaGen::emitDecls(const CodeModel::Unit* ds, QTextStream& out, int l)
{
    QList<CodeModel::Element*> consts = ds->getConsts();
    if( !consts.isEmpty() )
        out << ws(l) << "----- CONST -----" << endl;
    foreach( const CodeModel::Element* c, consts )
    {
        emitComment( c->d_def, out,l );
        out << ws(l) << "local " + escape(c->d_name) << " = "; // ASSIG

        if( c->d_const.canConvert<CodeModel::Set>() )
            out << "obnlj.SET(" << QByteArray::number( quint32(c->d_const.value<CodeModel::Set>().to_ulong()) ) << ")";
        else if( c->d_const.type() == QVariant::ByteArray )
            out << "obnlj.Str(\"" << luaStringEscape(c->d_const.toByteArray() ) << "\")";
        else
            out << c->d_const.toByteArray();
        out << endl;
        if( ds == d_curMod && c->d_public )
            out << "module" << "." << escape(c->d_name) << " = " << escape(c->d_name) << endl;
    }
    if( !consts.isEmpty() )
        out << endl;

    QList<CodeModel::Type*> namedTypes = ds->getNamedTypes();
    if( !namedTypes.isEmpty() )
        out << ws(l) << "----- TYPE -----" << endl;
    foreach( const CodeModel::Type* t, namedTypes )
    {
        emitComment( t->d_def, out,l );
        emitTypeDecl(ds,t,out,l);
    }
    if( !namedTypes.isEmpty() )
        out << endl;

    QList<CodeModel::Element*> vars = ds->getVars();
    if( !vars.isEmpty() )
        out << ws(l) << "----- VAR ------" << endl;
    foreach( const CodeModel::Element* v, vars )
    {
        emitComment( v->d_def, out,l );
        emitVarDecl(ds,v,out,l);
    }
    if( !vars.isEmpty() )
        out << endl;
}

void LuaGen::emitStatementSeq(const CodeModel::Unit* ds, const QList<SynTree*>& seq, QTextStream& out, int level)
{
    int count = 0;
    foreach( const SynTree* s, seq )
    {
        if( s->d_tok.d_type == SynTree::R_statement )
        {
            Q_ASSERT( s->d_children.size() <= 1 );
            if( s->d_children.isEmpty() )
                continue;
            else
                s = s->d_children.first();
        }
        emitComment(s,out,level);
        count++;
        switch( s->d_tok.d_type )
        {
        case SynTree::R_assignmentOrProcedureCall:
            Q_ASSERT( false ); // wurde bereits vorher korrigiert
            break;
        case SynTree::R_assignment_:
            emitAssig(ds, s, out, level );
            break;
        case SynTree::R_ProcedureCall_:
            out << ws(level);
            emitDesigList(ds, d_mdl->derefDesignator( ds, s->d_children.first() ), true, out, level);
            out << endl;
            break;
        case SynTree::R_IfStatement:
            emitIfStatement(ds, s, out, level );
            break;
        case SynTree::R_CaseStatement:
            emitCaseStatement(ds, s, out, level );
            break;
        case SynTree::R_WhileStatement:
            emitWhileStatement(ds,s,out,level);
            break;
        case SynTree::R_RepeatStatement:
            emitRepeatStatement(ds,s,out,level);
            break;
        case SynTree::R_ForStatement:
            emitForStatement(ds,s,out,level);
            break;
        case SynTree::R_ReturnStatement:
            // TODO: Kopie bei val-type {table.unpack(org)}
            out << ws(level) << "return "; // kein assig, da wir hier lhs nicht kontrollieren; nur rhs
            Q_ASSERT( s->d_children.size() == 2 && s->d_children.last()->d_tok.d_type == SynTree::R_expression );
            emitExpression(ds, s->d_children.last(), out, level );
            out << endl;
            break;
        default:
            out << ws(level) << "-- unknown statement " << SynTree::rToStr(s->d_tok.d_type) << endl;
            d_mdl->getErrs()->warning( Errors::Generator, s,
                                       tr("'%1' not yet supported").arg(SynTree::rToStr(s->d_tok.d_type)) );
            break;
        }
    }
//    if( count == 0 )
//        out << ws(level) << "-- empty statement" << endl;
}

bool LuaGen::emitPredefProc(const CodeModel::Unit* ds, const CodeModel::DesigOpList& dopl, QTextStream& out, int level)
{
    Q_ASSERT( !dopl.isEmpty() );
    const CodeModel::Element* pp = dopl.first().d_sym->to<CodeModel::Element>();
    Q_ASSERT( pp != 0 && pp->isPredefProc() );
    if( dopl.size() != 2 || dopl.last().d_op != CodeModel::ProcedureOp )
    {
        d_errs->error( Errors::Semantics, dopl.first().d_arg, tr("invalid call of built-in procedure '%1'").
                       arg(dopl.first().d_sym->d_name.data()) );
        return false;
    }
    Q_ASSERT( dopl.last().d_arg->d_tok.d_type == SynTree::R_ExpList );
    QList<SynTree*> args = dopl.last().d_arg->d_children;

    switch( pp->d_kind )
    {
    case CodeModel::Element::NEW:
        if( args.size() == 1 )
        {
            RecRef rr = getRecRefFrom(ds,args.first());
            if( rr.second == 0 )
            {
                d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'NEW()' expects a POINTER to RECORD") );
                return false;
            }
            QByteArray name;
            {
                d_suppressVar = true;
                QTextStream out2( &name, QIODevice::WriteOnly);
                emitExpression(ds, args.first(), out2, level );
                d_suppressVar = false;
            }
            const SynTree* d = CodeModel::flatten(const_cast<SynTree*>(args.first()), SynTree::R_designator);
            if( d == 0 )
            {
                d_mdl->getErrs()->error( Errors::Semantics, args.first(), tr("expecting designator as actual argument") );
                return false;
            }
            CodeModel::DesigOpList dopl = d_mdl->derefDesignator( ds, d );
            const bool var = countPrintable(dopl) == 1 && dopl.first().d_op == CodeModel::IdentOp && dopl.first().d_sym->d_var;
            if( rr.first )
                initRecord( ds, out, rr.first, name, var, level, true );
            else if( rr.second )
                initRecord( ds, out, rr.second, name, var, level, true );
            else
                initRecord( ds, out, 0, name, var, level, true );
            return true;
        }else
            d_mdl->getErrs()->error( Errors::Semantics, pp->d_def, tr("'NEW()' expects one argument") );
        break;
    case CodeModel::Element::INC:
        if( args.size() == 1 )
        {
            const SynTree* d = CodeModel::flatten( args.first(), SynTree::R_designator );
            if( d )
            {
                const bool thunk = emitAssig(ds, d, 0, out, level );
                emitExpression( ds, args.first(), out , level );
                out << " + 1";
                if( thunk )
                    out << ")";
                return true;
            }
        }else if( args.size() == 2 )
        {
            const SynTree* d = CodeModel::flatten( args.first(), SynTree::R_designator );
            if( d )
            {
                const bool thunk = emitAssig(ds, d, 0, out, level );
                emitExpression( ds, args.first(), out , level );
                out << " + ";
                emitExpression( ds, args.last(), out , level );
                if( thunk )
                    out << ")";
                return true;
            }
        }
        d_mdl->getErrs()->error( Errors::Semantics, pp->d_def, tr("'INC()' with invalid arguments") );
        break;
    case CodeModel::Element::DEC:
        if( args.size() == 1 )
        {
            const SynTree* d = CodeModel::flatten( args.first(), SynTree::R_designator );
            if( d )
            {
                const bool thunk = emitAssig(ds, d, 0, out, level );
                emitExpression( ds, args.first(), out , level );
                out << " - 1";
                if( thunk )
                    out << ")";
                return true;
            }
        }else if( args.size() == 2 )
        {
            const SynTree* d = CodeModel::flatten( args.first(), SynTree::R_designator );
            if( d )
            {
                const bool thunk = emitAssig(ds, d, 0, out, level );
                emitExpression( ds, args.first(), out , level );
                out << " - ";
                emitExpression( ds, args.last(), out , level );
                if( thunk )
                    out << ")";
                return true;
            }
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'DEC()' with invalid arguments") );
        break;
    case CodeModel::Element::ORD:
        if( args.size() == 1 )
        {
            out << "obnlj.ORD( ";
            emitExpression(ds, args.first(), out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ORD()' with invalid arguments") );
        break;
    case CodeModel::Element::CHR:
        if( args.size() == 1 )
        {
            out << "obnlj.Char( ";
            emitExpression(ds, args.first(), out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'CHR()' with invalid arguments") );
        break;
    case CodeModel::Element::ODD:
        if( args.size() == 1 )
        {
            d_suppressVar = true;
            emitExpression(ds, args.first(), out, level );
            out << " % 2 == 1";
            d_suppressVar = false;
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ODD()' with invalid arguments") );
        break;
    case CodeModel::Element::ASSERT:
        if( args.size() == 1 )
        {
            out << "obnlj.ASSERT(";
            emitExpression(ds, args.first(), out, level );
            out << ",\"" << args.first()->d_tok.d_sourcePath << "\"," << args.first()->d_tok.d_lineNr << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ASSERT()' with invalid arguments") );
        break;
    case CodeModel::Element::ABS:
        if( args.size() == 1 )
        {
            out << "math.abs( ";
            emitExpression(ds, args.first(), out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ABS()' with invalid arguments") );
        break;
    case CodeModel::Element::INCL:
        if( args.size() == 2 )
        {
            out << "obnlj.INCL(";
            emitExpression(ds, args.first(), out, level );
            out << ",";
            emitExpression(ds, args.last(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'INCL()' with invalid arguments") );
        break;
    case CodeModel::Element::EXCL:
        if( args.size() == 2 )
        {
            out << "obnlj.EXCL(";
            emitExpression(ds, args.first(), out, level );
            out << ",";
            emitExpression(ds, args.last(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'EXCL()' with invalid arguments") );
        break;
    case CodeModel::Element::PACK:
        if( args.size() == 2 )
        {
            out << "obnlj.PACK( ";
            emitActualParam( ds, args.first(), true, out, level );
            out << ", ";
            emitExpression(ds, args.last(), out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'EXCL()' with invalid arguments") );
        break;
    case CodeModel::Element::UNPK:
        if( args.size() == 2 )
        {
            out << "obnlj.UNPK( ";
            emitActualParam( ds, args.first(), true, out, level );
            out << ", ";
            emitActualParam( ds, args.last(), true, out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'EXCL()' with invalid arguments") );
        break;
    case CodeModel::Element::LEN:
        if( args.size() == 1 )
        {
            emitExpression(ds, args.first(), out, level );
            out << ".n ";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'LEN()' with invalid arguments") );
        break;
    case CodeModel::Element::LSL:
        if( args.size() == 2 )
        {
            out << "bit.lshift(";
            emitExpression(ds, args.first(), out, level );
            out << ",";
            emitExpression(ds, args.last(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'LSL()' with invalid arguments") );
        break;
    case CodeModel::Element::ASR:
        if( args.size() == 2 )
        {
            out << "bit.arshift(";
            emitExpression(ds, args.first(), out, level );
            out << ",";
            emitExpression(ds, args.last(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ASR()' with invalid arguments") );
        break;
    case CodeModel::Element::ROR:
        if( args.size() == 2 )
        {
            out << "bit.ror(";
            emitExpression(ds, args.first(), out, level );
            out << ",";
            emitExpression(ds, args.last(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ROR()' with invalid arguments") );
        break;
    case CodeModel::Element::FLOOR:
        if( args.size() == 1 )
        {
            out << "math.floor(";
            emitExpression(ds, args.first(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'FLOOR()' with invalid arguments") );
        break;
    case CodeModel::Element::FLT:
        if( args.size() == 1 )
        {
            emitExpression(ds, args.first(), out, level );
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'FLT()' with invalid arguments") );
        break;
    case CodeModel::Element::WriteChar:
        if( args.size() == 1 )
        {
            out << "Out.Char(";
            emitExpression(ds, args.first(), out, level );
            out << ")";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'WriteChar()' with invalid arguments") );
        break;
    case CodeModel::Element::WriteInt:
        if( args.size() == 1 )
        {
            out << "Out.Int(";
            emitExpression(ds, args.first(), out, level );
            out << ",4)";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'WriteInt()' with invalid arguments") );
        break;
    case CodeModel::Element::WriteReal:
        if( args.size() == 1 )
        {
            out << "Out.Real(";
            emitExpression(ds, args.first(), out, level );
            out << ",0)";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'WriteReal()' with invalid arguments") );
        break;
    case CodeModel::Element::WriteLn:
        if( args.size() == 0 )
        {
            out << "Out.Ln()";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'WriteLn()' with invalid arguments") );
        break;
    default:
        d_mdl->getErrs()->warning( Errors::Generator, dopl.last().d_arg,
                                   tr("built-in '%1()' not yet supported").arg(pp->d_name.data()) );
        break;
    }
    return false;
}

void LuaGen::emitIfStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_IfStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "if ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " then " << endl;
    SynTree* stats = st->d_children[3];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_ElsifStatement )
        {
            SynTree* elif = st->d_children[i];
            Q_ASSERT( elif->d_children.size() == 4 && elif->d_children[1]->d_tok.d_type == SynTree::R_expression &&
                      elif->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );
            out << ws(level) << "elseif ";
            emitExpression(ds,elif->d_children[1],out,level);
            out << " then" << endl;
            SynTree* stats = elif->d_children[3];
            emitStatementSeq(ds, stats->d_children, out, level + 1);
        }else if( st->d_children[i]->d_tok.d_type == SynTree::R_ElseStatement )
        {
            SynTree* els = st->d_children[i];
            Q_ASSERT( els->d_children.size() == 2 && els->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence );
            out << ws(level) << "else" << endl;
            SynTree* stats = els->d_children[1];
            emitStatementSeq(ds, stats->d_children, out, level + 1);
        }
    }
    out << ws(level) << "end" << endl;
}

void LuaGen::emitWhileStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_WhileStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "while true do" << endl;
    out << ws(level+1) << "if ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " then" << endl;
    emitStatementSeq(ds, st->d_children[3]->d_children, out, level + 2);
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_ElsifStatement2 )
        {
            Q_ASSERT( st->d_children[i]->d_children.size() == 4 &&
                      st->d_children[i]->d_children[1]->d_tok.d_type == SynTree::R_expression &&
                    st->d_children[i]->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );
            out << ws(level+1) << "elseif ";
            emitExpression(ds,st->d_children[i]->d_children[1],out,level+1);
            out << " then" << endl;
            emitStatementSeq(ds, st->d_children[i]->d_children[3]->d_children, out, level + 2);
        }
    }
    out << ws(level+1) << "else" << endl;
    out << ws(level+2) << "break" << endl;
    out << ws(level+1) << "end" << endl;
    out << ws(level) << "end" << endl;
    if( CodeModel::findFirstChild( st, SynTree::R_ElsifStatement ) != 0 )
        d_errs->warning(Errors::Generator, st, tr("ELSIF statement in WHILE statement not supported") );
}

void LuaGen::emitCaseStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_CaseStatement && st->d_children.size() >= 5 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_Case );
    QList<const SynTree*> cases;
    cases << st->d_children[3];
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_Case )
            cases << st->d_children[i];
    }
    const CodeModel::Type* t = derefed(d_mdl->typeOfExpression(ds, st->d_children[1]));
    if( t->d_kind == CodeModel::Type::Pointer || t->d_kind == CodeModel::Type::Record )
    {
        // type case
        SynTree* id = CodeModel::flatten(st->d_children[1]);
        Q_ASSERT( id->d_tok.d_type == Tok_ident );
        const CodeModel::NamedThing* var = ds->findByName( id->d_tok.d_val ) ;
        Q_ASSERT( var != 0 );

        int n = 0;
        for( int i = 0; i < cases.size(); i++ )
        {
            const SynTree* c = cases[i];
            if( c->d_children.isEmpty() )
                continue;
            Q_ASSERT( c->d_children.size() == 2 && c->d_children.first()->d_tok.d_type ==
                      SynTree::R_CaseLabelList && c->d_children.last()->d_tok.d_type == SynTree::R_StatementSequence );
            SynTree* cll = c->d_children.first();
            SynTree* q = CodeModel::flatten(cll,SynTree::R_qualident);
            if( q == 0 )
            {
                d_mdl->getErrs()->error( Errors::Semantics, cll,
                                         tr("in type case statements only qualidents supported as case labels") );
                continue;
            }
            out << ws(level) << ( n == 0 ? "if " : "elseif ");
            out << "obnlj.is_a( ";
            emitExpression(ds,st->d_children[1],out, level);
            out << ", ";
            CodeModel::Quali qq = d_mdl->derefQualident(ds,q);
            const CodeModel::Type* newType = dynamic_cast<const CodeModel::Type*>( qq.second.first );
            if( newType->d_kind == CodeModel::Type::Pointer )
            {
                newType = newType->d_type;
                Q_ASSERT( newType->d_kind == CodeModel::Type::TypeRef );
                out << quali(newType->d_st);
            }else
                out << quali(q);

            out << " ) then" << endl;

            CodeModel::Unit scope;
            scope.d_outer = const_cast<CodeModel::Unit*>(ds);
            CodeModel::TypeAlias alias;
            alias.d_name = id->d_tok.d_val;
            alias.d_newType = newType;
            alias.d_alias = const_cast<CodeModel::NamedThing*>(var);
            alias.d_var = var->d_var;
            scope.addToScope(&alias);

            emitStatementSeq(&scope,c->d_children.last()->d_children,out,level+1);
            n++;
        }
        if( n )
            out << ws(level) << "end" << endl;
    }else
    {
        // normal case
        int n = 0;
        for( int i = 0; i < cases.size(); i++ )
        {
            const SynTree* c = cases[i];
            if( c->d_children.isEmpty() )
                continue;
            Q_ASSERT( c->d_children.size() == 2 && c->d_children.first()->d_tok.d_type ==
                      SynTree::R_CaseLabelList && c->d_children.last()->d_tok.d_type == SynTree::R_StatementSequence );
            out << ws(level) << ( n == 0 ? "if " : "elseif ");
            SynTree* cll = c->d_children.first();
            for( int j = 0; j < cll->d_children.size(); j++ )
            {
                Q_ASSERT( cll->d_children[j]->d_tok.d_type == SynTree::R_LabelRange );
                SynTree* lr = cll->d_children[j];
                if( j != 0 )
                    out << " or ";
                if( lr->d_children.size() == 1 )
                {
                    emitExpression(ds,st->d_children[1],out, level);
                    out << " == ";
                    emitLabel( lr->d_children.first(), out );
                }else if( lr->d_children.size() == 3 )
                {
                    emitExpression(ds,st->d_children[1],out, level);
                    out << " >= ";
                    emitLabel( lr->d_children.first(), out );
                    out << " and ";
                    emitExpression(ds,st->d_children[1],out, level);
                    out << " <= ";
                    emitLabel( lr->d_children.last(), out );
                }else
                    Q_ASSERT( false );
            }
            out << " then" << endl;
            emitStatementSeq(ds,c->d_children.last()->d_children,out,level+1);
            n++;
        }
        if( n )
            out << ws(level) << "end" << endl;
    }
}

void LuaGen::emitRepeatStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_RepeatStatement && st->d_children.size() == 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence &&
              st->d_children[3]->d_tok.d_type == SynTree::R_expression );

    out << ws(level) << "repeat " << endl;
    SynTree* stats = st->d_children[1];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level) << "until ";
    emitExpression(ds,st->d_children[3],out,level);
    out << endl;
}

void LuaGen::emitForStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_ForStatement && st->d_children.size() >= 9 &&
            st->d_children[1]->d_tok.d_type == Tok_ident );
#if 0
    out << ws(level) << "for " << st->d_children[1]->d_tok.d_val << " = ";
    emitExpression(ds,st->d_children[3],out,level);
    out << ", ";
    emitExpression(ds,st->d_children[5],out,level);
    if( st->d_children[6]->d_tok.d_type == Tok_BY )
    {
        out << ", ";
        emitExpression(ds,st->d_children[7],out,level);
    }
    out << " do " << endl;
    SynTree* stat = CodeModel::findFirstChild( st, SynTree::R_StatementSequence, 6 );
    Q_ASSERT( stat != 0 );
    emitStatementSeq(ds, stat->d_children, out, level + 1);
    out << ws(level) << "end" << endl;
#endif
    // the same as while because in Lua the TO expression is only executed once
    out << ws(level) << st->d_children[1]->d_tok.d_val << " = "; // ASSIG
    emitExpression(ds,st->d_children[3],out,level);
    out << endl;

    int inc = 1;
    if( st->d_children[6]->d_tok.d_type == Tok_BY )
    {
        bool ok;
        int res = d_mdl->evalExpression(ds,st->d_children[7]).toInt(&ok);
        if( ok )
            inc = res;
    }
    out << ws(level) << "while " << st->d_children[1]->d_tok.d_val;
    if( inc > 0 )
        out << " <= ";
    else
        out << " >= ";
    emitExpression(ds,st->d_children[5],out,level);
    out << " do" << endl;
    SynTree* stat = CodeModel::findFirstChild( st, SynTree::R_StatementSequence, 6 );
    Q_ASSERT( stat != 0 );
    emitStatementSeq(ds, stat->d_children, out, level + 1);
    out << ws(level+1) << st->d_children[1]->d_tok.d_val << " = " << // ASSIG
           st->d_children[1]->d_tok.d_val << " + " << inc << endl;
    out << ws(level) << "end" << endl;
}

void LuaGen::emitSet(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st->d_tok.d_type == SynTree::R_set && st->d_children.size() >= 2 );
    out << "obnlj.SET(";

    for( int i = 1; i < st->d_children.size() - 1; i++ )
    {
        SynTree* el = st->d_children[i];
        Q_ASSERT( el->d_tok.d_type == SynTree::R_element && !el->d_children.isEmpty() );
        if( i != 1 )
            out << ",";
        if( el->d_children.size() == 1 ) // expr
        {
            emitExpression(ds, el->d_children.first(), out, level );
            out << ",-1";
        }else if( el->d_children.size() == 3 ) // expr .. expr
        {
            emitExpression(ds, el->d_children.first(), out, level );
            out << ",";
            emitExpression(ds, el->d_children.last(), out, level );
        }else
            Q_ASSERT( false );
    }
    out << ")";
}

void LuaGen::emitComment(const SynTree* st, QTextStream& out, int level )
{
#if 0
    if( st == 0 )
        return;

    while( d_nextCmt < d_cmts.size() && d_cmts[d_nextCmt].d_lineNr <= st->d_tok.d_lineNr )
    {
        const QByteArray str = d_cmts[d_nextCmt++].d_val;
        out << ws(level) << "--[[ " << str.mid(2,str.size()-4) << " ]]--" << endl;
    }
#endif
}

void LuaGen::emitLabel(const SynTree* st, QTextStream& out)
{
    Q_ASSERT( st->d_tok.d_type == SynTree::R_label && !st->d_children.isEmpty() );

    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case Tok_integer:
        out << first->d_tok.d_val;
        break;
    case Tok_string:
    case Tok_hexchar:
    case Tok_hexstring:
        renderString(out, first );
        break;
    case SynTree::R_qualident:
        out << quali(first);
        break;
    default:
        qWarning() << "unexpected" << SynTree::rToStr(first->d_tok.d_type) <<
                      first->d_tok.d_sourcePath << first->d_tok.d_lineNr;
        Q_ASSERT( false );
        break;
    }
}

void LuaGen::emitActualParam(const CodeModel::Unit* ds, const SynTree* st, bool isVarParam, QTextStream& out, int level )
{
    // TODO: kopiere table wenn val-type, {table.unpack(org)}

    if( !isVarParam )
    {
        emitExpression(ds, st, out, level );
        return;
    }
    // else

    const SynTree* d = CodeModel::flatten(const_cast<SynTree*>(st), SynTree::R_designator);
    if( d == 0 )
    {
        d_mdl->getErrs()->error( Errors::Semantics, st, tr("expecting designator as actual var argument") );
        return;
    }
    CodeModel::DesigOpList dopl = d_mdl->derefDesignator(ds,d);
    const int prints = countPrintable(dopl);

    // Es gibt in ObLuaGen nur local Variablen. Es muss aber unterschieden werden, ob der designator auf
    // einen Skalar oder eine Table zeigt. Der Skalar wird via Upvalue-Thunk implementiert, die Table via Table Thunk.

    Q_ASSERT( !dopl.isEmpty() );
    Q_ASSERT( dopl.last().d_op != CodeModel::ProcedureOp );

    const CodeModel::Module* m = dynamic_cast<const CodeModel::Module*>(dopl.first().d_sym);
    const CodeModel::Element* e = 0;
    if( prints == 1 && m == 0 )
        e = dynamic_cast<const CodeModel::Element*>(dopl[0].d_sym);
    if( prints > 1 )
        e = dynamic_cast<const CodeModel::Element*>(dopl[1].d_sym);
    if( ( prints == 1 && e != 0 && e->d_kind == CodeModel::Element::Variable ) ||
            ( prints == 2 && m != 0 && e != 0 && e->d_kind == CodeModel::Element::Variable ) )
    {
#if 0
        // use upvalue thunk
        out << "function(__0,__1) if __0 then ";
        const bool thunk = emitAssig(ds,d,0,out,level);
        out << " __1";
        if( thunk )
            out << ")";
        out << " else return ";
        emitExpression(ds, st, out, level );
        out << " end end";
#else

       if( !d_thunkNames.contains(st) )
        {
            d_suppressVar = true;
            emitExpression(ds, st, out, level ); // no thunk because we use the param recursively
            d_suppressVar = false;
        }else
            out << d_thunkNames[st];
#endif
        return;
    }
    // else
    out << "obnlj.thunk( ";

    // table
    for( int i = 0; i < dopl.size() - 1; i++ )
    {
        const CodeModel::DesigOp& dop = dopl[i];
        switch( dop.d_op )
        {
        case CodeModel::IdentOp:
            Q_ASSERT( dop.d_sym );
            if( i != 0 )
                out << ".";
            out << escape(dop.d_sym->d_name);
            break;
        case CodeModel::ProcedureOp:
            Q_ASSERT( false );
            break;
        case CodeModel::ArrayOp:
            emitArrayOp( ds, dop.d_arg, out, level );
            break;
        default:
            break;
        }
    }

    // index
    switch( dopl.last().d_op )
    {
    case CodeModel::IdentOp:
        Q_ASSERT( dopl.last().d_sym );
        out << ", \"" << escape(dopl.last().d_sym->d_name) << "\"";
        break;
    case CodeModel::ArrayOp:
        emitArrayOp( ds, dopl.last().d_arg, out, level, true );
        out << ", ";
        emitExpression(ds, dopl.last().d_arg->d_children.last(), out, level );
        out << " + 1";
        break;
    case CodeModel::PointerOp:
        break;
    default:
        Q_ASSERT( false );
        break;
    }

    out << " )";
}

void LuaGen::emitVarThunk(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
	// NOTE: inline declarations of thunks don't work yet with the LuaJIT optimizer; as soon as
	// an FNEW is in the trace it is aborted; if the thunk is temporarily stored in a slot instead
	// and if the declaration is moved outside of possible loops then optimization works with an incredible
	// speed-up compared to this implementation.

    const SynTree* d = CodeModel::flatten(const_cast<SynTree*>(st), SynTree::R_designator);
    if( d == 0 )
    {
        d_mdl->getErrs()->error( Errors::Semantics, st, tr("expecting designator as actual var argument") );
        return;
    }
    CodeModel::DesigOpList dopl = d_mdl->derefDesignator(ds,d);
    const int prints = countPrintable(dopl);

    // Es gibt in ObLuaGen nur local Variablen. Es muss aber unterschieden werden, ob der designator auf
    // einen Skalar oder eine Table zeigt. Der Skalar wird via Upvalue-Thunk implementiert, die Table via Table Thunk.

    Q_ASSERT( !dopl.isEmpty() );
    Q_ASSERT( dopl.last().d_op != CodeModel::ProcedureOp );

    const CodeModel::Module* m = dynamic_cast<const CodeModel::Module*>(dopl.first().d_sym);
    const CodeModel::Element* e = 0;
    if( prints == 1 && m == 0 )
        e = dynamic_cast<const CodeModel::Element*>(dopl[0].d_sym);
    if( prints > 1 )
        e = dynamic_cast<const CodeModel::Element*>(dopl[1].d_sym);
    if( ( prints == 1 && e != 0 && e->d_kind == CodeModel::Element::Variable ) ||
            ( prints == 2 && m != 0 && e != 0 && e->d_kind == CodeModel::Element::Variable ) )
    {
        // use upvalue thunk
        QByteArray name = "__t" + QByteArray::number(d_thunkNames.size());
        d_thunkNames[st] = name;
        out << ws(level) << "local " << name << " = " << "function(__0,__1) if __0 then ";
        const bool thunk = emitAssig(ds,d,0,out,level);
        out << " __1";
        if( thunk )
            out << ")";
        out << " else return ";
        emitExpression(ds, st, out, level );
        out << " end end" << endl;
    }
}

void LuaGen::emitArrayOp(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level, bool omitLast )
{
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_ExpList );
    const int off = omitLast ? 1 : 0;
    for( int j = 0; j < ( st->d_children.size() - off ); j++ )
    {
        // Oberon [x] or [x,y,z]
        out << "[";
        emitExpression(ds, st->d_children[j], out, level );
        out << " +1]"; // Lua is one-based, Oberon zero-based
    }
}

QByteArray LuaGen::escape(const QByteArray& id)
{
    if( isLuaKeyword(id) || startsWith2Underscores(id) )
        return id + "_";
    else
        return id;
}

void LuaGen::preprocVarParams(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level )
{
    if( st == 0 )
        return;

    // only statements are processed here
    // both variableOrFunctionCall and assignmentOrProcedureCall lead to designator
    if( st->d_tok.d_type == SynTree::R_designator )
    {
        CodeModel::DesigOpList dopl = d_mdl->derefDesignator( ds, st );

        if( dopl.isEmpty() || dopl.last().d_op != CodeModel::ProcedureOp )
        {
            preprocVarParams(ds,dopl,out,level);
            return; // we're only interested in procedure calls with args here
        }

        Q_ASSERT( dopl.size() > 1 );
        QList<bool> vars;
        const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>( dopl[ dopl.size() - 2 ].d_sym );
        if( e && e->isPredefProc() )
        {
            switch( e->d_kind )
            {
            case CodeModel::Element::PACK:
                vars << true << false;
                break;
            case CodeModel::Element::UNPK:
                vars << true << true;
                break;
            default:
                break;
            }
        }else
        {
            Q_ASSERT( dopl[ dopl.size() - 2 ].d_sym );
            QList<CodeModel::Element*> el = dopl[ dopl.size() - 2 ].d_sym->getParams();
            foreach( CodeModel::Element* e, el )
                vars << e->d_var;
        }

        QList<SynTree*> actuals;
        if( dopl.last().d_arg == 0 )
        {
            preprocVarParams(ds,dopl,out,level);
            return; // error will be later detected
        }

        Q_ASSERT( dopl.last().d_arg->d_tok.d_type == SynTree::R_ExpList );
        actuals = dopl.last().d_arg->d_children;
        if( actuals.size() != vars.size() )
        {
            preprocVarParams(ds,dopl,out,level);
            return; // predefproc or error, will be later detected
        }

        const bool isRecursiveCall = ( ds == dynamic_cast<const CodeModel::Procedure*>( dopl[ dopl.size() - 2 ].d_sym ) );
        for( int j = 0; j < actuals.size(); j++ )
        {
            if( vars[j] )
            {
                if( !isRecursiveCall ) // TODO: check for indirect recursion
                    emitVarThunk( ds, actuals[j], out, level );
                else
                {
                    out << ws(level) << "-- no thunk for VAR param ";
                    d_suppressVar = true;
                    emitExpression(ds,actuals[j],out,level);
                    d_suppressVar = false;
                    out << " in recursive call" << endl;
                }
            }
        }
        // and now go collect embedded designators
        preprocVarParams(ds,dopl,out,level);
    }else
    {
        foreach( const SynTree* sub, st->d_children )
            preprocVarParams( ds, sub, out, level );
    }
}

void LuaGen::preprocVarParams(const CodeModel::Unit* ds, const CodeModel::DesigOpList& dopl, QTextStream& out, int level)
{
    foreach( const CodeModel::DesigOp& dop, dopl )
        preprocVarParams(ds, dop.d_arg, out, level );
}

void LuaGen::emitTerm(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_term && !st->d_children.isEmpty() );
    if( st->d_children.size() == 1 )
        emitFactor(ds,st->d_children.first(),out,level);
    else
        emitTerm( ds, st->d_children, st->d_children.size() - 1, out, level );
}

void LuaGen::emitTerm(const CodeModel::Unit* ds, const QList<SynTree*> st, int i, QTextStream& out, int level)
{
    if( i < 0 )
        return;
    if( i == 0 )
    {
        emitFactor(ds,st[i],out,level);
        return;
    }
    Q_ASSERT( i >= 2 && i < st.size() );

    // a * b * c * d
    // ( ( ( a * b ) * c ) * d )

    SynTree* op = CodeModel::flatten( st[i-1] );

    if( op->d_tok.d_type == Tok_DIV || op->d_tok.d_type == Tok_MOD )
    {
        if( op->d_tok.d_type == Tok_DIV )
            out << "obnlj.DIV(";
        else
            out << "obnlj.MOD(";
        emitTerm(ds, st, i - 2, out, level );
        out << ",";
        emitFactor(ds,st[i],out,level);
        out << ")";
    }else
    {
        emitTerm(ds, st, i - 2, out, level );
        switch( op->d_tok.d_type )
        {
        case Tok_Star:
            out << " * ";
            break;
        case Tok_Slash:
            out << " / ";
            break;
        case Tok_Amp:
            out << " and ";
            break;
        default:
            out << " ?? ";
            break;
        }
        emitFactor(ds,st[i],out,level);
    }
}

void LuaGen::emitSimpleExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_SimpleExpression && !st->d_children.isEmpty() );
    int i = 0;
    if( st->d_children[i]->d_tok.d_type == Tok_Plus || st->d_children[i]->d_tok.d_type == Tok_Minus )
    {
        if( st->d_children[i]->d_tok.d_type == Tok_Minus ) // Lua has no + prefix
            out << tokenTypeString(st->d_children[i]->d_tok.d_type);
        i++;
    }
    emitTerm(ds,st->d_children[i++],out,level);
    while( i < st->d_children.size() )
    {
        SynTree* op = CodeModel::flatten( st->d_children[i++] );
        switch( op->d_tok.d_type )
        {
        case Tok_Plus:
            out << " + ";
            break;
        case Tok_Minus:
            out << " - ";
            break;
        case Tok_OR:
            out << " or ";
            break;
        default:
            out << " ?? ";
            break;
        }
        Q_ASSERT( i < st->d_children.size() );
        emitTerm(ds,st->d_children[i++],out,level);
    }
}

void LuaGen::emitExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && !st->d_children.isEmpty() );

    SynTree* op = 0;

    if( st->d_children.size() > 1 )
        op = CodeModel::flatten( st->d_children[1] );

    if( op && op->d_tok.d_type == Tok_IS )
    {
        Q_ASSERT( st->d_children.size() == 3 );
        RecRef rr = getRecRefFrom(ds,st->d_children.last());
        out << "obnlj.is_a( ";
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << ", ";
        if( rr.first )
            out << quali(rr.first->d_st);
        else if( rr.second )
            out << rr.second->d_name;
        else
            emitSimpleExpression(ds,st->d_children.last(),out,level); // TODO
        out << " ) ";
    }else if( op && op->d_tok.d_type == Tok_IN )
    {
        Q_ASSERT( st->d_children.size() == 3 );
        out << "obnlj.IN( ";
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << ", ";
        emitSimpleExpression(ds,st->d_children.last(),out,level);
        out << " )";
    }else
    {
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        if( st->d_children.size() > 1 )
        {
            switch( op->d_tok.d_type )
            {
            case Tok_Eq:
                out << " == ";
                break;
            case Tok_Hash:
                out << " ~= ";
                break;
            case Tok_Lt:
                out << " < ";
                break;
            case Tok_Leq:
                out << " <= ";
                break;
            case Tok_Gt:
                out << " > ";
                break;
            case Tok_Geq:
                out << " >= ";
                break;
            case Tok_IN:
                out << " IN ";
                Q_ASSERT( false ); // wird oben gelöst
                break;
            case Tok_IS:
                out << " IS ";
                Q_ASSERT( false ); // wird oben gelöst
                break;
            default:
                out << " ?? ";
                break;
            }
            emitSimpleExpression(ds,st->d_children.last(),out,level);
        }
    }
}

