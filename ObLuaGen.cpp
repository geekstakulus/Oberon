/*
* Copyright 2019 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Oberon parser/code model library.
*
* The following is the license that applies to this copy of the
* library. For a license to use the library under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "ObLuaGen.h"
#include <QDir>
#include <QtDebug>
#include <QCoreApplication>
#include <QDateTime>
#include <memory>
#include <typeinfo>
using namespace Ob;

// TODO compare output with http://oberon.wikidot.com/obenchmarks

static QSet<QByteArray> s_lkw;

static bool isLuaKeyword( const QByteArray& str )
{
    if( s_lkw.isEmpty() )
        s_lkw << "and" <<       "break" <<     "do" <<        "else" <<      "elseif"
              << "end" <<       "false" <<     "for" <<       "function" <<  "if"
              << "in" <<        "local" <<     "nil" <<       "not" <<       "or"
              << "repeat" <<    "return" <<    "then" <<      "true" <<      "until" <<     "while";
    return s_lkw.contains(str);
}

static inline const CodeModel::Type* derefed( const CodeModel::Type* t )
{
    return ( t != 0 ? t->deref() : 0 );
}

static QByteArray quali( const SynTree* st )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_qualident );
    if( st->d_children.size() == 1 )
        return st->d_children.first()->d_tok.d_val;
    else
        return st->d_children.first()->d_tok.d_val + "." + st->d_children.last()->d_tok.d_val;
}

LuaGen::LuaGen(CodeModel* mdl):d_mdl(mdl),d_errs(0),d_curMod(0)
{
    Q_ASSERT( mdl != 0 );
    d_errs = mdl->getErrs();
}

bool LuaGen::emitModules(const QString& outdir)
{
    QDir dir(outdir);

    const int precount = d_errs->getErrCount();
    foreach( CodeModel::Module* m, d_mdl->getGlobalScope().d_mods )
    {
        qDebug() << "translating module" << m->d_name;
        const QByteArray code = emitModule(m);
        if( !code.isEmpty() )
        {
            QFile out( dir.absoluteFilePath( m->d_name + ".lua" ) );
            if( !out.open(QIODevice::WriteOnly) )
                d_errs->error(Errors::Generator,m->d_name, 0,0,
                              QString("cannot open file '%1' for writing").arg(out.fileName()) );
            else
                out.write(code);
        }
    }
    return precount == int(d_errs->getErrCount());
}

QByteArray LuaGen::emitModule(const CodeModel::Module* m)
{
    Q_ASSERT( m && m->d_def );

    d_curMod = m;

    QByteArray code;
    QTextStream out(&code,QIODevice::WriteOnly);

    out << "-- Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
            " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    int l = 0;

    d_cmts.clear();
    if( m->d_def )
        d_cmts = d_mdl->getComments(m->d_def->d_tok.d_sourcePath);
    d_nextCmt = 0;

    out << "---------- MODULE ----------" << endl;
    out << "local " << escape(m->d_name) << " = {}" << endl << endl;
    emitComment(m->d_def,out,l);

    QList<const CodeModel::Module*> imps;
    CodeModel::Scope::Names::const_iterator i;
    for( i = m->d_names.begin(); i != m->d_names.end(); ++i )
    {
        if( CodeModel::Module* m = dynamic_cast<CodeModel::Module*>( i.value() ) )
            imps << m;
    }
    out << "local _obnlj = require '_obnlj'" << endl << endl;
    if( !imps.isEmpty() )
    {
        out << "----- IMPORT -----" << endl;
        foreach( const CodeModel::Module* m, imps )
        {
            emitComment(m->d_def,out,l);
            out << "local " << escape(i.key()) << " = require '" << escape(m->d_name) << "'" << endl;
        }
        out << endl;
    }

    emitDecls(m,out,l);

    if( !m->d_procs.isEmpty() )
        out << ws(l) << "----- PROC -----" << endl;
    foreach( const CodeModel::Procedure* v, m->d_procs )
    {
        emitProc(v,out,l);
    }
    if( !m->d_procs.isEmpty() )
        out << endl;

    if( !m->d_body.isEmpty() )
        out << ws(l) << "-- BEGIN" << endl;
    emitStatementSeq(m, m->d_body, out,l);
    if( !m->d_body.isEmpty() )
        out << ws(l) << "-- END" << endl;

    out << "return " << escape(m->d_name) << endl;
    out.flush();
    return code;
}

QString LuaGen::ws(int level)
{
    return QString(level,QChar('\t'));
}

void LuaGen::emitFactor(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_factor && !st->d_children.isEmpty() );
    const SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_set:
        emitSet(ds,first,out, level);
        break;
    case SynTree::R_number:
        Q_ASSERT( !st->d_children.first()->d_children.isEmpty() );
        if( st->d_children.first()->d_children.first()->d_tok.d_val.endsWith('H') )
            out << "0x" << st->d_children.first()->d_children.first()->d_tok.d_val.left(
                       st->d_children.first()->d_children.first()->d_tok.d_val.size() - 1 );
        else
            out << st->d_children.first()->d_children.first()->d_tok.d_val;
        break;
    case Tok_TRUE:
        out << "true";
        break;
    case Tok_FALSE:
        out << "false";
        break;
    case Tok_NIL:
        out << "nil";
        break;
    case Tok_Lpar:
        out << "(";
        Q_ASSERT(st->d_children.size() == 3);
        emitExpression(ds,st->d_children[1],out,level);
        out << ")";
        break;
    case Tok_Tilde:
        out << "not ";
        Q_ASSERT(st->d_children.size() == 2 );
        emitFactor(ds,st->d_children[1], out, level );
        break;
    case Tok_string:
        if( first->d_tok.d_val.size() == 3 )
            out << "'" << ( first->d_tok.d_val[1] == '\'' ? "\\" : "" ) << first->d_tok.d_val[1] << "'"; // CHAR
        else
            out << first->d_tok.d_val;
        break;
    case Tok_hexchar:
        out << "0x" << first->d_tok.d_val.left(first->d_tok.d_val.size() - 1 );
        break;
    case Tok_hexstring:
        out << "\"" << first->d_tok.d_val << "\"";
        break;
    case SynTree::R_variableOrFunctionCall:
        emitDesig(ds,first->d_children.first(), false, out,level);
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

bool LuaGen::emitDesig(const CodeModel::Unit* ds, const SynTree* st, bool procCall, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_designator );
    CodeModel::DesigOpList dopl = d_mdl->derefDesignator(ds,st);

    bool printedSomething = false;
    for( int i = 0; i < dopl.size(); i++ )
    {
        switch( dopl[i].d_op )
        {
        case CodeModel::IdentOp:
            Q_ASSERT( dopl[i].d_sym );
            if( i == 0 && dynamic_cast<const CodeModel::Module*>(dopl[i].d_sym) )
            {
                out << escape(dopl[i].d_sym->d_name) + ".";
                printedSomething = true;
            }else
            {
                const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>( dopl[i].d_sym );
                if( e && e->isPredefProc() )
                {
                    if( emitPredefProc( ds, dopl, out, level ) )
                        return true;
                    else
                        out << escape(dopl[i].d_sym->d_name);
                }else
                {
                    if( i != 0 )
                        out << ".";

                    out << escape(dopl[i].d_sym->d_name);
                    if( e && e->d_kind == CodeModel::Element::Variable )
                        const CodeModel::Type* t = derefed(e->d_type);
                }
            }
            break;
        case CodeModel::PointerOp:
            break;
        case CodeModel::TypeOp:
            break;
        case CodeModel::ProcedureOp:
            out << "(";
            if( dopl[i].d_arg )
            {
                // TODO: VAR params
                Q_ASSERT( dopl[i].d_arg->d_tok.d_type == SynTree::R_ExpList );
                for( int j = 0; j < dopl[i].d_arg->d_children.size(); j++ )
                {
                    if( j != 0 )
                        out << ", ";
                    emitExpression(ds, dopl[i].d_arg->d_children[j], out, 0 );
                }
            }
            out << ")";
            break;
        case CodeModel::ArrayOp:
            Q_ASSERT( dopl[i].d_arg->d_tok.d_type == SynTree::R_ExpList );
            for( int j = 0; j < dopl[i].d_arg->d_children.size(); j++ )
            {
                out << "[";
                emitExpression(ds, dopl[i].d_arg->d_children[j], out, 0 );
                out << " +1]"; // Lua is one-based, Oberon zero-based
            }
            break;
        default:
            break;
        }
    }
    if( procCall && !dopl.isEmpty() && dopl.last().d_op != CodeModel::ProcedureOp )
    {
        bool isCallWithoutParams = false;
        if( const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>(dopl.last().d_sym) )
        {
            isCallWithoutParams = ( e->d_kind == CodeModel::Element::StubProc ) ||
                    ( e->d_type && e->d_type->d_kind == CodeModel::Type::ProcRef );
        }else if( dynamic_cast<const CodeModel::Procedure*>(dopl.last().d_sym) )
            isCallWithoutParams = true;
        else if( const CodeModel::Type* t = dynamic_cast<const CodeModel::Type*>(dopl.last().d_sym) )
            isCallWithoutParams = t->d_kind == CodeModel::Type::ProcRef;
        if( isCallWithoutParams )
            out << "()";
    }

    return printedSomething;
}

void LuaGen::emitTypeDecl(const CodeModel::Unit* ds, const CodeModel::Type* t, QTextStream& out, int level)
{
    Q_ASSERT( !t->d_name.isEmpty() );
    const CodeModel::Type* td = derefed(t);
    if( t->d_kind == CodeModel::Type::Record )
    {
        const QByteArray name = escape(t->d_name);
        out << ws(level) << "local " << name << " = ";
        if( t->d_type )
        {
            Q_ASSERT( t->d_type->d_kind == CodeModel::Type::TypeRef );
            out << "_obnlj.instance( " << quali( t->d_type->d_st ) << " )" << endl;
        }else
            out << "{}" << endl;

    }else if( t->d_kind == CodeModel::Type::TypeRef && td && td->d_kind == CodeModel::Type::Record )
    {
        out << ws(level) << "local " << t->d_name << " = " << quali(t->d_st) << endl;
    }
    // else: es gibt keine Typendeklarationen für alle übrigen typen
}

void LuaGen::initMatrix( QTextStream& out, const QList<const CodeModel::Type*>& mat, const QByteArray& name, int level, int i )
{
    if( i >= ( mat.size() - 1 ) )
        return;
    out << ws(level+i) << "for __" << i << "=1," << mat[i]->d_len << " do" << endl;
    out << ws(level+i+1) << name;
    for( int j = 0; j <= i; j++ )
        out << "[__" << j << "]";
    out << " = {}" << endl;
    initMatrix(out,mat,name,level, i+1 );
    out << ws(level+i) << "end" << endl;
}

void LuaGen::emitVarDecl(const CodeModel::Unit* ds, const CodeModel::Element* v, QTextStream& out, int level)
{
    const CodeModel::Type* td = derefed(v->d_type);
    const QByteArray name = escape(v->d_name);
    out << ws(level) << "local " << name << " = ";
    if( td && td->d_kind == CodeModel::Type::Record )
    {
        if( td->d_type )
        {
            Q_ASSERT( td->d_st && td->d_st->d_tok.d_type == SynTree::R_qualident );
            out << "_obnlj.instance(" << quali( td->d_st ) << ")" << endl;
        }else
            out << " {}" << endl;

    }else if( td && td->d_kind == CodeModel::Type::Array )
    {
        out << "{}" << endl;
        QList<const CodeModel::Type*> dims;
        while( td && td->d_kind == CodeModel::Type::Array )
        {
            dims << td;
            td = derefed( td->d_type );
        }
        initMatrix( out, dims, name, level, 0 );
    }else
        out << "nil" << endl;
}

void LuaGen::emitProc(const CodeModel::Procedure* p, QTextStream& out, int level)
{
    const CodeModel::Module* m = p->getModule();
    Q_ASSERT( m != 0 );

    emitComment(p->d_def,out,0);

    out << ws(level) << "local function " << escape(p->d_name);

    out << "(";
    for( int i = 0; i < p->d_vals.size(); i++ )
    {
        if( i != 0 )
            out << ", ";
        const CodeModel::Element* par = p->d_vals[i];
        out << escape(par->d_name);
    }
    out << ")" << endl;

    emitDecls(p,out,level+1);

    if( !p->d_body.isEmpty() )
    {
        out << ws(level+1) << "-- BEGIN" << endl;
    }
    emitStatementSeq(p,p->d_body,out,level+1);
    if( !p->d_body.isEmpty() )
        out << ws(level+1) << "-- END" << endl;

    out << ws(level) << "end" << endl << endl;
}

void LuaGen::emitDecls(const CodeModel::Unit* ds, QTextStream& out, int l)
{
    QList<CodeModel::Element*> consts = ds->getConsts();
    if( !consts.isEmpty() )
        out << ws(l) << "----- CONST -----" << endl;
    foreach( const CodeModel::Element* c, consts )
    {
        emitComment( c->d_def, out,l );
        out << "local " + escape(c->d_name) << " = ";

        if( c->d_const.canConvert<CodeModel::Set>() )
            out << QString("0x%1").arg( c->d_const.value<CodeModel::Set>().to_ulong(), 16 );
        else
            out << c->d_const.toString();
        out << endl;
    }
    if( !consts.isEmpty() )
        out << endl;

    QList<CodeModel::Type*> namedTypes = ds->getNamedTypes();
    if( !namedTypes.isEmpty() )
        out << ws(l) << "----- TYPE -----" << endl;
    foreach( const CodeModel::Type* t, namedTypes )
    {
        emitComment( t->d_def, out,l );
        emitTypeDecl(ds,t,out,l);
    }
    if( !namedTypes.isEmpty() )
        out << endl;

    QList<CodeModel::Element*> vars = ds->getVars();
    if( !vars.isEmpty() )
        out << ws(l) << "----- VAR ------" << endl;
    foreach( const CodeModel::Element* v, vars )
    {
        emitComment( v->d_def, out,l );
        emitVarDecl(ds,v,out,l);
    }
    if( !vars.isEmpty() )
        out << endl;
}

void LuaGen::emitStatementSeq(const CodeModel::Unit* ds, const QList<SynTree*>& seq, QTextStream& out, int level)
{
    int count = 0;
    foreach( const SynTree* s, seq )
    {
        if( s->d_tok.d_type == SynTree::R_statement )
        {
            Q_ASSERT( s->d_children.size() <= 1 );
            if( s->d_children.isEmpty() )
                continue;
            else
                s = s->d_children.first();
        }
        emitComment(s,out,level);
        count++;
        switch( s->d_tok.d_type )
        {
        case SynTree::R_assignmentOrProcedureCall:
            Q_ASSERT( false ); // wurde bereits vorher korrigiert
            break;
        case SynTree::R_assignment:
            // TODO: VAR params
            out << ws(level);
            emitDesig(ds, s->d_children.first(), false, out, level);
            out << " = ";
            emitExpression(ds,s->d_children.last(), out, level );
            out << endl;
            break;
        case SynTree::R_ProcedureCall:
            out << ws(level);
            // TODO: VAR params with return values
            emitDesig(ds, s->d_children.first(), true, out, level);
            out << endl;
            break;
        case SynTree::R_IfStatement:
            emitIfStatement(ds, s, out, level );
            break;
        case SynTree::R_CaseStatement:
            emitCaseStatement(ds, s, out, level );
            break;
        case SynTree::R_WhileStatement:
            emitWhileStatement(ds,s,out,level);
            break;
        case SynTree::R_RepeatStatement:
            emitRepeatStatement(ds,s,out,level);
            break;
        case SynTree::R_ForStatement:
            emitForStatement(ds,s,out,level);
            break;
        case SynTree::R_ReturnStatement:
            // TODO: VAR params
            out << ws(level) << "return ";
            Q_ASSERT( s->d_children.size() == 2 && s->d_children.last()->d_tok.d_type == SynTree::R_expression );
            emitExpression(ds, s->d_children.last(), out, level );
            out << endl;
            break;
        default:
            out << ws(level) << "-- unknown statement " << SynTree::rToStr(s->d_tok.d_type) << endl;
            d_mdl->getErrs()->warning( Errors::Generator, s,
                                       tr("'%1' not yet supported").arg(SynTree::rToStr(s->d_tok.d_type)) );
            break;
        }
    }
    if( count == 0 )
    {
        out << ws(level) << "-- empty statement" << endl;
    }
}

bool LuaGen::emitPredefProc(const CodeModel::Unit* ds, const CodeModel::DesigOpList& dopl, QTextStream& out, int level)
{
    Q_ASSERT( !dopl.isEmpty() );
    const CodeModel::Element* pp = dopl.first().d_sym->to<CodeModel::Element>();
    Q_ASSERT( pp != 0 && pp->isPredefProc() );
    if( dopl.size() != 2 || dopl.last().d_op != CodeModel::ProcedureOp )
    {
        d_errs->error( Errors::Semantics, dopl.first().d_arg, tr("invalid call of built-in procedure '%1'").
                       arg(dopl.first().d_sym->d_name.data()) );
        return false;
    }
    Q_ASSERT( dopl.last().d_arg->d_tok.d_type == SynTree::R_ExpList );
    QList<SynTree*> args = dopl.last().d_arg->d_children;

    switch( pp->d_kind )
    {
    case CodeModel::Element::NEW:
        {
            const SynTree* desig = ( args.isEmpty() ? 0 : CodeModel::flatten(args.first(), SynTree::R_designator ) );
            if( args.size() != 1 || desig == 0 )
            {
                d_errs->error( Errors::Semantics, dopl.last().d_arg, tr("invalid arguments of 'NEW()'") );
                return false;
            }
            CodeModel::DesigOpList arg = d_mdl->derefDesignator( ds, desig );
            const CodeModel::Element* id = 0;
            const CodeModel::Type* ptr = 0;
            const CodeModel::Type* rec = 0;
            if( arg.isEmpty() || arg.last().d_op != CodeModel::IdentOp ||
                    ( id = arg.last().d_sym->to<CodeModel::Element>() ) == 0 ||
                    ( ptr = derefed( id->d_type ) ) == 0 || ptr->d_kind != CodeModel::Type::Pointer ||
                    ( rec = derefed( ptr->d_type ) ) == 0 || rec->d_kind != CodeModel::Type::Record )
            {
                d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'NEW()' expects a POINTER to RECORD") );
                return false;
            }
            emitDesig(ds, desig, false, out, level );
            out << " = _obnlj.instance( ";

            if( rec->d_scope != ds )
                out << escape(rec->d_scope->d_name) << ".";
            out << escape(rec->d_name);

            out << " )";
            return true;
        }
        break;
    case CodeModel::Element::INC:
        if( args.size() == 1 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " = ";
            emitExpression( ds, args.first(), out , level );
            out << " + 1";
            return true;
        }else if( args.size() == 2 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " = ";
            emitExpression( ds, args.first(), out , level );
            out << " + ";
            emitExpression( ds, args.last(), out , level );
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, pp->d_def, tr("'INC()' with invalid arguments") );
        break;
    case CodeModel::Element::DEC:
        if( args.size() == 1 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " = ";
            emitExpression( ds, args.first(), out , level );
            out << " - 1";
            return true;
        }else if( args.size() == 2 )
        {
            emitExpression( ds, args.first(), out , level );
            out << " = ";
            emitExpression( ds, args.first(), out , level );
            out << " - ";
            emitExpression( ds, args.last(), out , level );
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'DEC()' with invalid arguments") );
        break;
    case CodeModel::Element::ORD:
        if( args.size() == 1 )
        {
            // TODO
            const CodeModel::Type* t = d_mdl->typeOfExpression(ds, args.first() );
            if( t == d_mdl->getGlobalScope().d_setType )
            {
                out << "( ";
                emitExpression(ds, args.first(), out, level );
                out << " ).to_ulong()";
                return true;
            }else
            {
                out << "int( ";
                emitExpression(ds, args.first(), out, level );
                out << " )";
                return true;
            }
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ORD()' with invalid arguments") );
        break;
    case CodeModel::Element::CHR:
        if( args.size() == 1 )
        {
            // TODO
            out << "char( ";
            emitExpression(ds, args.first(), out, level );
            out << " )";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'CHR()' with invalid arguments") );
        break;
    case CodeModel::Element::ODD:
        if( args.size() == 1 )
        {
            emitExpression(ds, args.first(), out, level );
            out << " % 2 == 1";
            return true;
        }
        d_mdl->getErrs()->error( Errors::Semantics, dopl.last().d_arg, tr("'ODD()' with invalid arguments") );
        break;
    default:
        d_mdl->getErrs()->warning( Errors::Generator, dopl.last().d_arg,
                                   tr("built-in '%1()' not yet supported").arg(pp->d_name.data()) );
        break;
    }
    return false;
}

static inline bool ifNeedsBlock( SynTree* stats )
{
    Q_ASSERT( stats->d_tok.d_type == SynTree::R_StatementSequence );
    if( stats->d_children.isEmpty() )
        return false;
    SynTree* stat = stats->d_children.first();
    Q_ASSERT( stat->d_tok.d_type == SynTree::R_statement );
    if( stat->d_children.isEmpty() )
        return false;
    if( stat->d_children.first()->d_tok.d_type == SynTree::R_IfStatement )
        return true;
    else
        return stats->d_children.size() > 1;
}

void LuaGen::emitIfStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_IfStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "if ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " then " << endl;
    SynTree* stats = st->d_children[3];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_ElsifStatement )
        {
            SynTree* elif = st->d_children[i];
            Q_ASSERT( elif->d_children.size() == 4 && elif->d_children[1]->d_tok.d_type == SynTree::R_expression &&
                      elif->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );
            out << "elseif ";
            emitExpression(ds,elif->d_children[1],out,level);
            out << " then" << endl;
            SynTree* stats = elif->d_children[3];
            emitStatementSeq(ds, stats->d_children, out, level + 1);
        }else if( st->d_children[i]->d_tok.d_type == SynTree::R_ElseStatement )
        {
            SynTree* els = st->d_children[i];
            Q_ASSERT( els->d_children.size() == 2 && els->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence );
            out << "else" << endl;
            SynTree* stats = els->d_children[1];
            emitStatementSeq(ds, stats->d_children, out, level + 1);
        }
    }
    out << "end" << endl;
}

void LuaGen::emitWhileStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_WhileStatement && st->d_children.size() >= 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_StatementSequence );

    out << ws(level) << "while ";
    emitExpression(ds,st->d_children[1],out,level);
    out << " do" << endl;
    SynTree* stats = st->d_children[3];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level) << "end" << endl;
    if( CodeModel::findFirstChild( st, SynTree::R_ElsifStatement ) != 0 )
        d_errs->warning(Errors::Generator, st, tr("ELSIF statement in WHILE statement not supported") );
}

void LuaGen::emitCaseStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_CaseStatement && st->d_children.size() >= 5 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_expression &&
              st->d_children[3]->d_tok.d_type == SynTree::R_Case );
    QList<const SynTree*> cases;
    cases << st->d_children[3];
    for( int i = 4; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_Case )
            cases << st->d_children[i];
    }
    const CodeModel::Type* t = derefed(d_mdl->typeOfExpression(ds, st->d_children[1]));
    if( t->d_kind == CodeModel::Type::Pointer || t->d_kind == CodeModel::Type::Record )
    {
        // type case
        SynTree* id = CodeModel::flatten(st->d_children[1]);
        Q_ASSERT( id->d_tok.d_type == Tok_ident );
        const CodeModel::NamedThing* var = ds->findByName( id->d_tok.d_val ) ;
        Q_ASSERT( var != 0 );

        int n = 0;
        for( int i = 0; i < cases.size(); i++ )
        {
            const SynTree* c = cases[i];
            if( c->d_children.isEmpty() )
                continue;
            Q_ASSERT( c->d_children.size() == 2 && c->d_children.first()->d_tok.d_type ==
                      SynTree::R_CaseLabelList && c->d_children.last()->d_tok.d_type == SynTree::R_StatementSequence );
            SynTree* cll = c->d_children.first();
            SynTree* q = CodeModel::flatten(cll,SynTree::R_qualident);
            if( q == 0 )
            {
                d_mdl->getErrs()->error( Errors::Semantics, cll,
                                         tr("in type case statements only qualidents supported as case labels") );
                continue;
            }
            out << ws(level) << ( n == 0 ? "if " : "elseif ");
            out << "_obnjs.is_a( ";
            emitExpression(ds,st->d_children[1],out, level);
            out << ", " << quali(q) << " ) then" << endl;

            CodeModel::Quali qq = d_mdl->derefQualident(ds,q);
            const CodeModel::Type* newType = dynamic_cast<const CodeModel::Type*>( qq.second.first );
            CodeModel::Unit scope;
            scope.d_outer = const_cast<CodeModel::Unit*>(ds);
            CodeModel::TypeAlias alias;
            alias.d_name = id->d_tok.d_val;
            alias.d_newType = newType;
            alias.d_alias = const_cast<CodeModel::NamedThing*>(var);
            scope.addToScope(&alias);

            emitStatementSeq(&scope,c->d_children.last()->d_children,out,level+1);
            n++;
        }
        if( n )
            out << ws(level) << "end" << endl;
    }else
    {
        // normal case

        // TODO
    }

}

void LuaGen::emitRepeatStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_RepeatStatement && st->d_children.size() == 4 &&
            st->d_children[1]->d_tok.d_type == SynTree::R_StatementSequence &&
              st->d_children[3]->d_tok.d_type == SynTree::R_expression );

    out << ws(level) << "repeat " << endl;
    SynTree* stats = st->d_children[1];
    emitStatementSeq(ds, stats->d_children, out, level + 1);
    out << ws(level) << "until ";
    emitExpression(ds,st->d_children[3],out,level);
    out << endl;
}

void LuaGen::emitForStatement(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_ForStatement && st->d_children.size() >= 9 &&
            st->d_children[1]->d_tok.d_type == Tok_ident );
    out << ws(level) << "for " << st->d_children[1]->d_tok.d_val << " = ";
    emitExpression(ds,st->d_children[3],out,level);
    out << ", ";
    emitExpression(ds,st->d_children[5],out,level);
    if( st->d_children[6]->d_tok.d_type == Tok_BY )
    {
        out << ", ";
        emitExpression(ds,st->d_children[7],out,level);
    }
    out << " do " << endl;
    SynTree* stat = CodeModel::findFirstChild( st, SynTree::R_StatementSequence, 6 );
    Q_ASSERT( stat != 0 );
    emitStatementSeq(ds, stat->d_children, out, level + 1);
    out << ws(level) << "end" << endl;
}

void LuaGen::emitSet(const CodeModel::Unit* ds, const SynTree* st, QTextStream& out, int level)
{
    // TODO
    Q_ASSERT( st->d_tok.d_type == SynTree::R_set && st->d_children.size() >= 2 );
    out << "( _Set() ";

    for( int i = 1; i < st->d_children.size() - 2; i++ )
    {
        SynTree* el = st->d_children[i];
        Q_ASSERT( el->d_tok.d_type == SynTree::R_element && !el->d_children.isEmpty() );
        out << "+ ";
        if( el->d_children.size() == 1 )
        {
            out << "(";
            emitExpression(ds, el->d_children.first(), out, level );
            out << ") ";
        }else
        {
            out << "_Set( ";
            emitExpression(ds, el->d_children.first(), out, level );
            out << ", ";
            emitExpression(ds, el->d_children.last(), out, level );
            out << ") ";
        }
    }
    out << ")";
}

void LuaGen::emitComment(const SynTree* st, QTextStream& out, int level )
{
    if( st == 0 )
        return;

    while( d_nextCmt < d_cmts.size() && d_cmts[d_nextCmt].d_lineNr <= st->d_tok.d_lineNr )
    {
        const QByteArray str = d_cmts[d_nextCmt++].d_val;
        out << ws(level) << "--[[ " << str.mid(2,str.size()-4) << " ]]--" << endl;
    }
}

QByteArray LuaGen::escape(const QByteArray& id)
{
    if( isLuaKeyword(id) )
        return id + "_";
    else
        return id;
}

void LuaGen::emitTerm(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level )
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_term && !st->d_children.isEmpty() );
    if( st->d_children.size() == 1 )
        emitFactor(ds,st->d_children.first(),out,level);
    else
        emitTerm( ds, st->d_children, st->d_children.size() - 1, out, level );
}

void LuaGen::emitTerm(const CodeModel::Unit* ds, const QList<SynTree*> st, int i, QTextStream& out, int level)
{
    if( i < 0 )
        return;
    if( i == 0 )
    {
        emitFactor(ds,st[i],out,level);
        return;
    }
    Q_ASSERT( i >= 2 && i < st.size() );

    // a * b * c * d
    // ( ( ( a * b ) * c ) * d )

    SynTree* op = CodeModel::flatten( st[i-1] );

    if( op->d_tok.d_type == Tok_DIV || op->d_tok.d_type == Tok_MOD )
    {
        if( op->d_tok.d_type == Tok_DIV )
            out << "_obnlj.DIV(";
        else
            out << "_obnlj.MOD(";
        emitTerm(ds, st, i - 2, out, level );
        out << ",";
        emitFactor(ds,st[i],out,level);
        out << ")";
    }else
    {
        emitTerm(ds, st, i - 2, out, level );
        switch( op->d_tok.d_type )
        {
        case Tok_Star:
            out << " * ";
            break;
        case Tok_Slash:
            out << " / ";
            break;
        case Tok_Amp:
            out << " and ";
            break;
        default:
            out << " ?? ";
            break;
        }
        emitFactor(ds,st[i],out,level);
    }
}

void LuaGen::emitSimpleExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && st->d_tok.d_type == SynTree::R_SimpleExpression && !st->d_children.isEmpty() );
    int i = 0;
    if( st->d_children[i]->d_tok.d_type == Tok_Plus || st->d_children[i]->d_tok.d_type == Tok_Minus )
    {
        out << tokenTypeString(st->d_children[i]->d_tok.d_type);
        i++;
    }
    emitTerm(ds,st->d_children[i++],out,level);
    while( i < st->d_children.size() )
    {
        SynTree* op = CodeModel::flatten( st->d_children[i++] );
        switch( op->d_tok.d_type )
        {
        case Tok_Plus:
            out << " + ";
            break;
        case Tok_Minus:
            out << " - ";
            break;
        case Tok_OR:
            out << " or ";
            break;
        default:
            out << " ?? ";
            break;
        }
        Q_ASSERT( i < st->d_children.size() );
        emitTerm(ds,st->d_children[i++],out,level);
    }
}

void LuaGen::emitExpression(const CodeModel::Unit* ds,const SynTree* st, QTextStream& out, int level)
{
    Q_ASSERT( st != 0 && !st->d_children.isEmpty() );

    SynTree* op = 0;

    if( st->d_children.size() > 1 )
        op = CodeModel::flatten( st->d_children[1] );

    if( op && op->d_tok.d_type == Tok_IS )
    {
        Q_ASSERT( st->d_children.size() == 3 );
        SynTree* q = d_mdl->flatten(st->d_children[2],SynTree::R_qualident);
        out << "_obnlj.is_a( ";
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << ", " << quali(q) << " )" << endl;
    }else if( op && op->d_tok.d_type == Tok_IN )
    {
        // TODO
        Q_ASSERT( st->d_children.size() == 3 );
        emitSimpleExpression(ds,st->d_children.last(),out,level);
        out << ".contains( "; // TODO
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        out << " )";
    }else
    {
        emitSimpleExpression(ds,st->d_children.first(),out,level);
        if( st->d_children.size() > 1 )
        {
            switch( op->d_tok.d_type )
            {
            case Tok_Eq:
                out << " == ";
                break;
            case Tok_Hash:
                out << " ~= ";
                break;
            case Tok_Lt:
                out << " < ";
                break;
            case Tok_Leq:
                out << " <= ";
                break;
            case Tok_Gt:
                out << " > ";
                break;
            case Tok_Geq:
                out << " >= ";
                break;
            case Tok_IN:
                out << " IN ";
                Q_ASSERT( false ); // wird oben gelöst
                break;
            case Tok_IS:
                out << " IS ";
                Q_ASSERT( false ); // wird oben gelöst
                break;
            default:
                out << " ?? ";
                break;
            }
            emitSimpleExpression(ds,st->d_children.last(),out,level);
        }
    }
}

