-- Generated by OBNLC 2019-12-17 on 2019-12-17T22:13:12

---------- MODULE Hennessy ----------
local module = {}

local obnlj = require 'obnlj'
local Input = require 'Input'
local Out = require 'Out'
local bubblebase = 1.61
local dnfbase = 3.5
local permbase = 1.75
local queensbase = 1.83
local towersbase = 2.39
local quickbase = 1.92
local intmmbase = 1.46
local treebase = 2.5
local mmbase = 0
local fpmmbase = 2.92
local puzzlebase = 0.5
local fftbase = 0
local fpfftbase = 4.44
local maxcells = 18
local stackrange = 3
local rowsize = 40
local size = 511
local classmax = 3
local typemax = 12
local d = 8
local sortelements = 5000
local srtelements = 500
local fftsize = 256
local fftsize2 = 129
local permrange = 10
local nodeDesc = {}
local element = {}
local complex = {}
local fixed
local floated
local seed
local permarray = obnlj.Arr(11)
local pctr
local tree
local stack = obnlj.Arr(4)
local cellspace = obnlj.Arr(19)
	for __0=1,19 do
		local __r0 = {}
		cellspace[__0] = __r0
		setmetatable(__r0,element)
	end
local freelist
local movesdone
local ima = obnlj.Arr(41)
	for __0=1,41 do
		ima[__0] = obnlj.Arr(41)
	end
local imb = obnlj.Arr(41)
	for __0=1,41 do
		imb[__0] = obnlj.Arr(41)
	end
local imr = obnlj.Arr(41)
	for __0=1,41 do
		imr[__0] = obnlj.Arr(41)
	end
local rma = obnlj.Arr(41)
	for __0=1,41 do
		rma[__0] = obnlj.Arr(41)
	end
local rmb = obnlj.Arr(41)
	for __0=1,41 do
		rmb[__0] = obnlj.Arr(41)
	end
local rmr = obnlj.Arr(41)
	for __0=1,41 do
		rmr[__0] = obnlj.Arr(41)
	end
local piececount = obnlj.Arr(4)
local class = obnlj.Arr(13)
local piecemax = obnlj.Arr(13)
local puzzl = obnlj.Arr(512)
local p = obnlj.Arr(13)
	for __0=1,13 do
		p[__0] = obnlj.Arr(512)
	end
local n
local kount
local sortlist = obnlj.Arr(5001)
local biggest
local littlest
local top
local z = obnlj.Arr(257)
	for __0=1,257 do
		local __r0 = {}
		z[__0] = __r0
		setmetatable(__r0,complex)
	end
local w = obnlj.Arr(257)
	for __0=1,257 do
		local __r0 = {}
		w[__0] = __r0
		setmetatable(__r0,complex)
	end
local e = obnlj.Arr(130)
	for __0=1,130 do
		local __r0 = {}
		e[__0] = __r0
		setmetatable(__r0,complex)
	end
local zr
local zi
local function Str(s)
	local i
	-- BEGIN
	i = 0
	while true do
		if s[i+1] ~= obnlj.Str("\0") then
			if s[i+1] == obnlj.Str("$") then 
				Out.Ln()
			else
				Out.Char(s[i+1])
			end
			i = i + 1
		else
			break
		end
	end

end
module.Str = Str
local function Getclock()
	-- BEGIN
	return Input.Time()
end
local function Initrand()
	-- BEGIN
	seed = 74755

end
local function Rand()
	-- BEGIN
	seed = obnlj.MOD(seed * 1309 + 13849,65535)
	return seed
end
local function Swap(a,b)
	local t
	-- BEGIN
	t = a
	a = b
	b = t
	return a,b
end
local function Initialize()
	local i
	-- BEGIN
	i = 1
	while true do
		if i <= 7 then
			permarray[i+1] = i - 1
			i = i + 1
		else
			break
		end
	end

end
local function Permute(n)
	local k
	-- BEGIN
	pctr = pctr + 1
	if n ~= 1 then 
		Permute(n - 1)
		k = n - 1
		while true do
			if k >= 1 then
				__t0 = permarray
				__i0 = n
				__t1 = permarray
				__i1 = k
				__t0[__i0+1],__t1[__i1+1] = Swap(__t0[__i0+1],__t1[__i1+1])
				Permute(n - 1)
				__t0 = permarray
				__i0 = n
				__t1 = permarray
				__i1 = k
				__t0[__i0+1],__t1[__i1+1] = Swap(__t0[__i0+1],__t1[__i1+1])
				k = k - 1
			else
				break
			end
		end
	end

end
local function Perm()
	local i
	-- BEGIN
	pctr = 0
	i = 1
	while true do
		if i <= 5 then
			Initialize()
			Permute(7)
			i = i + 1
		else
			break
		end
	end
	if pctr ~= 43300 then 
		Str(obnlj.Str(" Error in Perm.$"))
	end

end
module.Perm = Perm
local function Makenull(s)
	-- BEGIN
	stack[s+1] = 0

end
local function Getelement()
	local temp
	-- BEGIN
	if freelist > 0 then 
		temp = freelist
		freelist = cellspace[freelist+1].next
	else
		Str(obnlj.Str("out of space   $"))
	end
	return temp
end
local function Push(i,s)
	local localel
	local errorfound
	-- BEGIN
	errorfound = false
	if stack[s+1] > 0 then 
		if cellspace[stack[s+1]+1].discsize <= i then 
			errorfound = true
			Str(obnlj.Str("disc size error$"))
		end
	end
	if not ( errorfound ) then 
		localel = Getelement()
		cellspace[localel+1].next = stack[s+1]
		stack[s+1] = localel
		cellspace[localel+1].discsize = i
	end

end
local function Init(s,n)
	local discctr
	-- BEGIN
	Makenull(s)
	discctr = n
	while true do
		if discctr >= 1 then
			Push(discctr,s)
			discctr = discctr - 1
		else
			break
		end
	end

end
local function Pop(s)
	local temp
	local temp1
	-- BEGIN
	if stack[s+1] > 0 then 
		temp1 = cellspace[stack[s+1]+1].discsize
		temp = cellspace[stack[s+1]+1].next
		cellspace[stack[s+1]+1].next = freelist
		freelist = stack[s+1]
		stack[s+1] = temp
	else
		Str(obnlj.Str("nothing to pop $"))
		temp1 = 0
	end
	return temp1
end
local function Move(s1,s2)
	-- BEGIN
	Push(Pop(s1),s2)
	movesdone = movesdone + 1

end
local function tower(i,j,k)
	local other
	-- BEGIN
	if k == 1 then 
		Move(i,j)
	else
		other = 6 - i - j
		tower(i,other,k - 1)
		Move(i,j)
		tower(other,j,k - 1)
	end

end
local function Towers()
	local i
	-- BEGIN
	i = 1
	while true do
		if i <= maxcells then
			cellspace[i+1].next = i - 1
			i = i + 1
		else
			break
		end
	end
	freelist = maxcells
	Init(1,14)
	Makenull(2)
	Makenull(3)
	movesdone = 0
	tower(1,2,14)
	if movesdone ~= 16383 then 
		Str(obnlj.Str(" Error in Towers.$"))
	end

end
module.Towers = Towers
local function Try(i,q,a,b,c,x)
	local j
	-- BEGIN
	j = 0
	q = false
	while true do
		if not ( q ) and j ~= 8 then
			j = j + 1
			q = false
			if b[j+1] and a[i + j+1] and c[i - j + 7+1] then 
				x[i+1] = j
				b[j+1] = false
				a[i + j+1] = false
				c[i - j + 7+1] = false
				if i < 8 then 
					q,a,b,c,x = Try(i + 1,q,a,b,c,x)
					if not ( q ) then 
						b[j+1] = true
						a[i + j+1] = true
						c[i - j + 7+1] = true
					end
				else
					q = true
				end
			end
		else
			break
		end
	end
	return q,a,b,c,x
end
local function Doit()
	local i
	local q
	local a = obnlj.Arr(9)
	local b = obnlj.Arr(17)
	local c = obnlj.Arr(15)
	local x = obnlj.Arr(9)
	-- BEGIN
	i = 0 - 7
	while true do
		if i <= 16 then
			if i >= 1 and i <= 8 then 
				a[i+1] = true
			end
			if i >= 2 then 
				b[i+1] = true
			end
			if i <= 7 then 
				c[i + 7+1] = true
			end
			i = i + 1
		else
			break
		end
	end
	q,b,a,c,x = Try(1,q,b,a,c,x)
	if not ( q ) then 
		Str(obnlj.Str(" Error in Queens.$"))
	end

end
local function Queens()
	local i
	-- BEGIN
	i = 1
	while true do
		if i <= 50 then
			Doit()
			i = i + 1
		else
			break
		end
	end

end
module.Queens = Queens
local function Initmatrix(m)
	local temp
	local i
	local j
	-- BEGIN
	i = 1
	while true do
		if i <= rowsize then
			j = 1
			while true do
				if j <= rowsize then
					temp = Rand()
					m[i+1][j+1] = temp - obnlj.DIV(temp,120) * 120 - 60
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	return m
end
local function Innerproduct(result,a,b,row,column)
	local i
	-- BEGIN
	result = 0
	i = 1
	while true do
		if i <= rowsize then
			result = result + a[row+1][i+1] * b[i+1][column+1]
			i = i + 1
		else
			break
		end
	end
	return result,a,b
end
local function Intmm()
	local i
	local j
	-- BEGIN
	Initrand()
	ima = Initmatrix(ima)
	imb = Initmatrix(imb)
	i = 1
	while true do
		if i <= rowsize then
			j = 1
			while true do
				if j <= rowsize then
					__t0 = imr[i+1]
					__i0 = j
					__t0[__i0+1],ima,imb = Innerproduct(__t0[__i0+1],ima,imb,i,j)
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end

end
module.Intmm = Intmm
local function rInitmatrix(m)
	local temp
	local i
	local j
	-- BEGIN
	i = 1
	while true do
		if i <= rowsize then
			j = 1
			while true do
				if j <= rowsize then
					temp = Rand()
					m[i+1][j+1] = obnlj.DIV(temp - obnlj.DIV(temp,120) * 120 - 60,3)
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	return m
end
local function rInnerproduct(result,a,b,row,column)
	local i
	-- BEGIN
	result = 0
	i = 1
	while true do
		if i <= rowsize then
			result = result + a[row+1][i+1] * b[i+1][column+1]
			i = i + 1
		else
			break
		end
	end
	return result,a,b
end
local function Mm()
	local i
	local j
	-- BEGIN
	Initrand()
	rma = rInitmatrix(rma)
	rmb = rInitmatrix(rmb)
	i = 1
	while true do
		if i <= rowsize then
			j = 1
			while true do
				if j <= rowsize then
					__t0 = rmr[i+1]
					__i0 = j
					__t0[__i0+1],rma,rmb = rInnerproduct(__t0[__i0+1],rma,rmb,i,j)
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end

end
module.Mm = Mm
local function Fit(i,j)
	local k
	local res
	-- BEGIN
	k = 0
	res = true
	while true do
		if k <= piecemax[i+1] then
			if p[i+1][k+1] then 
				if puzzl[j + k+1] then 
					res = false
				end
			end
			k = k + 1
		else
			break
		end
	end
	return res
end
local function Place(i,j)
	local k
	local res
	-- BEGIN
	k = 0
	res = 0
	while true do
		if k <= piecemax[i+1] then
			if p[i+1][k+1] then 
				puzzl[j + k+1] = true
			end
			k = k + 1
		else
			break
		end
	end
	piececount[class[i+1]+1] = piececount[class[i+1]+1] - 1
	k = j
	while true do
		if k <= size then
			if not ( puzzl[k+1] ) then 
				res = k
			end
			k = k + 1
		else
			break
		end
	end
	return res
end
local function Remove(i,j)
	local k
	-- BEGIN
	k = 0
	while true do
		if k <= piecemax[i+1] then
			if p[i+1][k+1] then 
				puzzl[j + k+1] = false
			end
			k = k + 1
		else
			break
		end
	end
	piececount[class[i+1]+1] = piececount[class[i+1]+1] + 1

end
local function Trial(j)
	local i
	local k
	local res
	-- BEGIN
	i = 0
	res = false
	kount = kount + 1
	while true do
		if i <= typemax then
			if piececount[class[i+1]+1] ~= 0 then 
				if Fit(i,j) then 
					k = Place(i,j)
					if Trial(k) or k == 0 then 
						res = true
					else
						Remove(i,j)
					end
				end
			end
			i = i + 1
		else
			break
		end
	end
	return res
end
local function Puzzle()
	local i
	local j
	local k
	local m
	-- BEGIN
	m = 0
	while true do
		if m <= size then
			puzzl[m+1] = true
			m = m + 1
		else
			break
		end
	end
	i = 1
	while true do
		if i <= 5 then
			j = 1
			while true do
				if j <= 5 then
					k = 1
					while true do
						if k <= 5 then
							puzzl[i + d * j + d * k+1] = false
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	i = 0
	while true do
		if i <= typemax then
			m = 0
			while true do
				if m <= size then
					p[i+1][m+1] = false
					m = m + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	i = 0
	while true do
		if i <= 3 then
			j = 0
			while true do
				if j <= 1 then
					k = 0
					while true do
						if k <= 0 then
							p[0+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[0+1] = 0
	piecemax[0+1] = 3 + d * 1 + d * d * 0
	i = 0
	while true do
		if i <= 1 then
			j = 0
			while true do
				if j <= 0 then
					k = 0
					while true do
						if k <= 3 then
							p[1+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[1+1] = 0
	piecemax[1+1] = 1 + d * 0 + d * d * 3
	i = 0
	while true do
		if i <= 0 then
			j = 0
			while true do
				if j <= 3 then
					k = 0
					while true do
						if k <= 1 then
							p[2+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[2+1] = 0
	piecemax[2+1] = 0 + d * 3 + d * d * 1
	i = 0
	while true do
		if i <= 1 then
			j = 0
			while true do
				if j <= 3 then
					k = 0
					while true do
						if k <= 0 then
							p[3+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[3+1] = 0
	piecemax[3+1] = 1 + d * 3 + d * d * 0
	i = 0
	while true do
		if i <= 3 then
			j = 0
			while true do
				if j <= 0 then
					k = 0
					while true do
						if k <= 1 then
							p[4+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[4+1] = 0
	piecemax[4+1] = 3 + d * 0 + d * d * 1
	i = 0
	while true do
		if i <= 0 then
			j = 0
			while true do
				if j <= 1 then
					k = 0
					while true do
						if k <= 3 then
							p[5+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[5+1] = 0
	piecemax[5+1] = 0 + d * 1 + d * d * 3
	i = 0
	while true do
		if i <= 2 then
			j = 0
			while true do
				if j <= 0 then
					k = 0
					while true do
						if k <= 0 then
							p[6+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[6+1] = 1
	piecemax[6+1] = 2 + d * 0 + d * d * 0
	i = 0
	while true do
		if i <= 0 then
			j = 0
			while true do
				if j <= 2 then
					k = 0
					while true do
						if k <= 0 then
							p[7+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[7+1] = 1
	piecemax[7+1] = 0 + d * 2 + d * d * 0
	i = 0
	while true do
		if i <= 0 then
			j = 0
			while true do
				if j <= 0 then
					k = 0
					while true do
						if k <= 2 then
							p[8+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[8+1] = 1
	piecemax[8+1] = 0 + d * 0 + d * d * 2
	i = 0
	while true do
		if i <= 1 then
			j = 0
			while true do
				if j <= 1 then
					k = 0
					while true do
						if k <= 0 then
							p[9+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[9+1] = 2
	piecemax[9+1] = 1 + d * 1 + d * d * 0
	i = 0
	while true do
		if i <= 1 then
			j = 0
			while true do
				if j <= 0 then
					k = 0
					while true do
						if k <= 1 then
							p[10+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[10+1] = 2
	piecemax[10+1] = 1 + d * 0 + d * d * 1
	i = 0
	while true do
		if i <= 0 then
			j = 0
			while true do
				if j <= 1 then
					k = 0
					while true do
						if k <= 1 then
							p[11+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[11+1] = 2
	piecemax[11+1] = 0 + d * 1 + d * d * 1
	i = 0
	while true do
		if i <= 1 then
			j = 0
			while true do
				if j <= 1 then
					k = 0
					while true do
						if k <= 1 then
							p[12+1][i + d * j + d * k+1] = true
							k = k + 1
						else
							break
						end
					end
					j = j + 1
				else
					break
				end
			end
			i = i + 1
		else
			break
		end
	end
	class[12+1] = 3
	piecemax[12+1] = 1 + d * 1 + d * d * 1
	piececount[0+1] = 13
	piececount[1+1] = 3
	piececount[2+1] = 1
	piececount[3+1] = 1
	m = 1 + d * 1 + d * 1
	kount = 0
	if Fit(0,m) then 
		n = Place(0,m)
	else
		Str(obnlj.Str("Error1 in Puzzle$"))
	end
	if not ( Trial(n) ) then 
		Str(obnlj.Str("Error2 in Puzzle.$"))
	elseif kount ~= 2005 then
		Str(obnlj.Str("Error3 in Puzzle.$"))
	end

end
module.Puzzle = Puzzle
local function Initarr()
	local i
	local temp
	-- BEGIN
	Initrand()
	biggest = 0
	littlest = 0
	i = 1
	while true do
		if i <= sortelements then
			temp = Rand()
			sortlist[i+1] = temp - obnlj.DIV(temp,100000) * 100000 - 50000
			if sortlist[i+1] > biggest then 
				biggest = sortlist[i+1]
			elseif sortlist[i+1] < littlest then
				littlest = sortlist[i+1]
			end
			i = i + 1
		else
			break
		end
	end

end
local function Quicksort(a,l,r)
	local i
	local j
	local x
	local w
	-- BEGIN
	i = l
	j = r
	x = a[obnlj.DIV(l + r,2)+1]
	repeat 
		while true do
			if a[i+1] < x then
				i = i + 1
			else
				break
			end
		end
		while true do
			if x < a[j+1] then
				j = j - 1
			else
				break
			end
		end
		if i <= j then 
			w = a[i+1]
			a[i+1] = a[j+1]
			a[j+1] = w
			i = i + 1
			j = j - 1
		end
	until i > j
	if l < j then 
		a = Quicksort(a,l,j)
	end
	if i < r then 
		a = Quicksort(a,i,r)
	end
	return a
end
local function Quick()
	-- BEGIN
	Initarr()
	sortlist = Quicksort(sortlist,1,sortelements)
	if sortlist[1+1] ~= littlest or sortlist[sortelements+1] ~= biggest then 
		Str(obnlj.Str(" Error in Quick.$"))
	end

end
module.Quick = Quick
local function bInitarr()
	local i
	local temp
	-- BEGIN
	Initrand()
	biggest = 0
	littlest = 0
	i = 1
	while true do
		if i <= srtelements then
			temp = Rand()
			sortlist[i+1] = temp - obnlj.DIV(temp,100000) * 100000 - 50000
			if sortlist[i+1] > biggest then 
				biggest = sortlist[i+1]
			elseif sortlist[i+1] < littlest then
				littlest = sortlist[i+1]
			end
			i = i + 1
		else
			break
		end
	end

end
local function Bubble()
	local i
	local j
	-- BEGIN
	bInitarr()
	top = srtelements
	while true do
		if top > 1 then
			i = 1
			while true do
				if i < top then
					if sortlist[i+1] > sortlist[i + 1+1] then 
						j = sortlist[i+1]
						sortlist[i+1] = sortlist[i + 1+1]
						sortlist[i + 1+1] = j
					end
					i = i + 1
				else
					break
				end
			end
			top = top - 1
		else
			break
		end
	end
	if sortlist[1+1] ~= littlest or sortlist[srtelements+1] ~= biggest then 
		Str(obnlj.Str("Error3 in Bubble.$"))
	end

end
module.Bubble = Bubble
local function tInitarr()
	local i
	local temp
	-- BEGIN
	Initrand()
	biggest = 0
	littlest = 0
	i = 1
	while true do
		if i <= sortelements then
			temp = Rand()
			sortlist[i+1] = temp - obnlj.DIV(temp,100000) * 100000 - 50000
			if sortlist[i+1] > biggest then 
				biggest = sortlist[i+1]
			elseif sortlist[i+1] < littlest then
				littlest = sortlist[i+1]
			end
			i = i + 1
		else
			break
		end
	end

end
local function CreateNode(t,n)
	local __tmp1
	-- BEGIN
	__tmp1 = {}
	t = __tmp1
	setmetatable(__tmp1,nodeDesc)
	t.left = null
	t.right = null
	t.val = n
	return t
end
local function Insert(n,t)
	-- BEGIN
	if n > t.val then 
		if t.left == null then 
			t.left = CreateNode(t.left,n)
		else
			Insert(n,t.left)
		end
	elseif n < t.val then
		if t.right == null then 
			t.right = CreateNode(t.right,n)
		else
			Insert(n,t.right)
		end
	end

end
local function Checktree(p)
	local result
	-- BEGIN
	result = true
	if p.left ~= null then 
		if p.left.val <= p.val then 
			result = false
		else
			result = Checktree(p.left) and result
		end
	end
	if p.right ~= null then 
		if p.right.val >= p.val then 
			result = false
		else
			result = Checktree(p.right) and result
		end
	end
	return result
end
local function Trees()
	local i
	local __tmp1
	-- BEGIN
	tInitarr()
	__tmp1 = {}
	tree = __tmp1
	setmetatable(__tmp1,nodeDesc)
	tree.left = null
	tree.right = null
	tree.val = sortlist[1+1]
	i = 2
	while true do
		if i <= sortelements then
			Insert(sortlist[i+1],tree)
			i = i + 1
		else
			break
		end
	end
	if not ( Checktree(tree) ) then 
		Str(obnlj.Str(" Error in Tree.$"))
	end

end
module.Trees = Trees
local function Cos(x)
	local i
	local factor
	local result
	local power
	-- BEGIN
	result = 1
	factor = 1
	power = x
	i = 2
	while true do
		if i <= 10 then
			factor = factor * i
			power = power * x
			if obnlj.MOD(i,2) == 0 then 
				if obnlj.MOD(i,4) == 0 then 
					result = result + power / factor
				else
					result = result - power / factor
				end
			end
			i = i + 1
		else
			break
		end
	end
	return result
end
local function Min0(arg1,arg2)
	local res
	-- BEGIN
	res = 0
	if arg1 < arg2 then 
		res = arg1
	else
		res = arg2
	end
	return res
end
local function Uniform11(iy,yfl)
	-- BEGIN
	iy = obnlj.MOD(4855 * iy + 1731,8192)
	yfl = iy / 8192

end
local function Exptab(n,e)
	local theta
	local divisor
	local d3
	local h = obnlj.Arr(26)
	local i
	local j
	local k
	local l
	local m
	local d1
	local d2
	-- BEGIN
	theta = 3.1415926536
	divisor = 4
	i = 1
	while true do
		if i <= 25 then
			h[i+1] = 1 / 2 * Cos(theta / divisor)
			divisor = divisor + divisor
			i = i + 1
		else
			break
		end
	end
	m = obnlj.DIV(n,2)
	l = obnlj.DIV(m,2)
	j = 1
	e[1+1].rp = 1
	e[1+1].ip = 0
	e[l + 1+1].rp = 0
	e[l + 1+1].ip = 1
	e[m + 1+1].rp = -1
	e[m + 1+1].ip = 0
	repeat 
		i = obnlj.DIV(l,2)
		k = i
		repeat 
			d1 = k + i + 1
			d2 = k - i + 1
			d3 = e[d2+1].rp
			e[k + 1+1].rp = h[j+1] * e[d1+1].rp + d3
			d3 = e[d2+1].ip
			e[k + 1+1].ip = h[j+1] * e[d1+1].ip + d3
			k = k + l
		until k > m
		j = Min0(j + 1,25)
		l = i
	until l <= 1
	return e
end
local function Fft(n,z,w,e,sqrinv)
	local i
	local j
	local k
	local l
	local m
	local index
	local h
	local d1
	local d2
	-- BEGIN
	m = obnlj.DIV(n,2)
	l = 1
	repeat 
		k = 0
		j = l
		i = 1
		repeat 
			repeat 
				w[i + k+1].rp = z[i+1].rp + z[m + i+1].rp
				w[i + k+1].ip = z[i+1].ip + z[m + i+1].ip
				h = e[k + 1+1].rp * z[i+1].rp - z[i + m+1].rp
				d1 = z[i+1].ip - z[i + m+1].ip
				w[i + j+1].rp = h - e[k + 1+1].ip * d1
				h = e[k + 1+1].rp * z[i+1].ip - z[i + m+1].ip
				d1 = z[i+1].rp - z[i + m+1].rp
				w[i + j+1].ip = h + e[k + 1+1].ip * d1
				i = i + 1
			until i > j
			k = j
			j = k + l
		until j > m
		index = 1
		repeat 
			z[index+1] = w[index+1]
			index = index + 1
		until index > n
		l = l + l
	until l > m
	i = 1
	while true do
		if i <= n then
			z[i+1].rp = sqrinv * z[i+1].rp
			z[i+1].ip = -sqrinv * z[i+1].ip
			i = i + 1
		else
			break
		end
	end
	return z,w,e
end
local function Oscar()
	local i
	-- BEGIN
	e = Exptab(fftsize,e)
	seed = 5767
	i = 1
	while true do
		if i <= fftsize then
			Uniform11(seed,zr)
			Uniform11(seed,zi)
			z[i+1].rp = 20 * zr - 10
			z[i+1].ip = 20 * zi - 10
			i = i + 1
		else
			break
		end
	end
	i = 1
	while true do
		if i <= 20 then
			z,w,e = Fft(fftsize,z,w,e,0.0625)
			i = i + 1
		else
			break
		end
	end

end
module.Oscar = Oscar
local function Time(s,p,base,fbase)
	local timer
	local i
	-- BEGIN
	Str(s)
	i = 0
	timer = Getclock()
	while true do
		if i < 10 then
			p()
			i = i + 1
		else
			break
		end
	end
	timer = Getclock() - timer
	Out.Int(timer,8)
	Out.Ln()
	fixed = fixed + timer * base
	floated = floated + timer * fbase

end
local function Do()
	-- BEGIN
	fixed = 0
	floated = 0
	Time(obnlj.Str("Perm "),Perm,permbase,permbase)
	Time(obnlj.Str("Towers "),Towers,towersbase,towersbase)
	Time(obnlj.Str("Queens "),Queens,queensbase,queensbase)
	Time(obnlj.Str("Intmm "),Intmm,intmmbase,intmmbase)
	Time(obnlj.Str("Mm "),Mm,mmbase,fpmmbase)
	Time(obnlj.Str("Quick "),Quick,quickbase,quickbase)
	Time(obnlj.Str("Bubble "),Bubble,bubblebase,bubblebase)
	Time(obnlj.Str("Tree "),Trees,treebase,treebase)
	Time(obnlj.Str("FFT "),Oscar,fftbase,fpfftbase)
	Str(obnlj.Str("Nonfloating point composite is "))
	Out.Real(fixed,10)
	Out.Ln()
	Str(obnlj.Str("Floating point composite is "))
	Out.Real(floated,10)
	Out.Ln()

end
module.Do = Do
zr = 0
zi = 0
Do()
return module
---------- END MODULE Hennessy ----------
