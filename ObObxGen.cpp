/*
* Copyright 2020-2021 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Oberon parser/code model library.
*
* The following is the license that applies to this copy of the
* library. For a license to use the library under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "ObObxGen.h"
#include <QCoreApplication>
#include <QDateTime>
#include <QDir>
#include <QtDebug>
using namespace Ob;

static inline SynTree* findFirstChild(const SynTree* st, int type , int startWith = 0, int* pos = 0 )
{
    if( st == 0 )
        return 0;
    for( int i = startWith; i < st->d_children.size(); i++ )
    {
        SynTree* sub = st->d_children[i];
        if( sub->d_tok.d_type == type )
        {
            if( pos )
                *pos = i;
            return sub;
        }
    }
    return 0;
}

ObxGen::ObxGen(CodeModel* mdl):d_mdl(mdl),d_errs(0),d_genStubs(true),
    nlAfterDeclHeader(true), nlPerDecl(true), nlPerStat(true), nlAfterBegin(true), nlBeforeEnd(true),
    noWchar(true), switchBBoxTypes(true)
{
    Q_ASSERT( mdl != 0 );
    d_errs = mdl->getErrs();
    reservedWords
            // keywords
            << "array" << "begin" << "by" << "case" << "definition" << "div" << "mod"
            << "do" << "else" << "elsif" << "end" << "exit" << "false" << "for"
            << "if" << "import" << "in" << "is" << "loop" << "module"
            << "nil" << "of" << "or" << "pointer" << "proc" << "procedure"
            << "record" << "repeat" << "return" << "then" << "to"
            << "true" << "type" << "var" << "while" << "with"
               // predeclared
            << "abs" << "ash" << "asr" << "assert" << "boolean"<< "byte"
            << "cap" << "char" << "chr" << "copy" << "dec" << "entier"
            << "excl" << "floor" << "flt" << "halt" << "inc" << "incl"
            << "int" << "integer" << "len"
            << "long" << "longint" << "longreal" << "lsl" << "max"
            << "min" << "new" << "odd" << "ord" << "pack" << "real"
            << "ror" << "set" << "short" << "shortint" << "size"
            << "unpk" << "val";
}

bool ObxGen::emitModules(const QString& outdir, const QString& mod)
{
    d_outdir = outdir;
    d_mod = mod;
    d_nameNr = 1;
    const int precount = d_errs->getErrCount();
    foreach( CodeModel::Module* m, d_mdl->getGlobalScope().d_mods )
    {
        qDebug() << "translating module" << m->d_name;
        emitModule(m);
    }
    return precount == int(d_errs->getErrCount());
}

void ObxGen::emitModule(const CodeModel::Module* m)
{
    root = m->d_def;
    QDir dir(d_outdir);
    if( !d_mod.isEmpty() )
    {
        dir.mkpath( d_mod );
        dir.cd( d_mod );
    }
    QFile file( dir.absoluteFilePath( m->d_name + ".obx" ));
    if( !file.open(QIODevice::WriteOnly ) )
    {
        d_errs->error(Errors::Generator,m->d_name, 0,0,QString("cannot open file '%1' for writing").arg(file.fileName()) );
        return;
    }

    out.setDevice(&file);

#if 0
    out << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
            " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;
#endif

    int lh = 0;

    d_cmts.clear();
    if( m->d_def )
        d_cmts = d_mdl->getComments(m->d_def->d_tok.d_sourcePath);
    d_nextCmt = 0;

    if( m->d_def )
        module( m,m->d_def );
    else
        module( m );
}

void ObxGen::module(const CodeModel::Unit* u, SynTree* st)
{
    d_isDef = false;
    level = 0;
    prevRow = 1;
    prevSym = 0;
    rowPrinted = false;
    if( st )
    {
        Q_ASSERT( st->d_children.size() >= 2 );
        if(
        #ifdef OB_BBOX
                findFirstChild( st, SynTree::R_SysString ) ||
        #endif
                st->d_children.first()->d_tok.d_type == Tok_DEFINITION )
        {
            d_isDef = true;
            print("definition ", st->d_children.first() );
        }else
            print("module ", st->d_children.first() );

        print( st->d_children[1] );

        if( st->d_children.size() > 2 )
            assureNl( st->d_children[2],2 );

        level++;
        SynTree* il = findFirstChild( st, SynTree::R_ImportList );
        if( il )
            importList( u, il );

        SynTree* dl = findFirstChild( st, SynTree::R_DeclarationSequence );
        if( dl )
            declarationSequence( u, dl );

        dl = findFirstChild( st, SynTree::R_DeclarationSequence2 );
        if( dl )
            declarationSequence2( u, dl );

        int pos;

        level--;
        if( SynTree* t = findFirstChild( st, Tok_BEGIN, 0, &pos ) )
        {
            Q_ASSERT( st->d_children.size() > pos + 1 );
            print("begin", t);
            level++;
            Q_ASSERT( pos+1 < st->d_children.size() );
            if( ifStatAfterBegin(st->d_children[pos+1]) )
                assureNl( st->d_children[pos+1] );
            statementSequence( u, st->d_children[pos+1] );
            level--;
        }

#ifdef OB_BBOX
        if( SynTree* t = findFirstChild( st, Tok_CLOSE, 0, &pos ) )
        {
            Q_ASSERT( st->d_children.size() > pos + 1 );
            print("(* CLOSE", t );
            level++;
            Q_ASSERT( pos+1 < st->d_children.size() );
            if( ifStatAfterBegin(st->d_children[pos+1]) )
                assureNl( st->d_children[pos+1] );
            statementSequence( u, st->d_children[pos+1] );
            level--;
            print(" *) ");
        }
#endif

        if( SynTree* t = findFirstChild( st, Tok_END, 0, &pos ) )
        {
            Q_ASSERT( st->d_children.size() > pos + 1 );
            if( nlBeforeEnd )
                assureNl(t);
            print("end ", t);
            print( st->d_children[pos+1] );
            newLine();
        }
    }
}

void ObxGen::module(const CodeModel::Module* m)
{
    out << "// Generated/synthesized by " << qApp->applicationName() << " " << qApp->applicationVersion() <<
            " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    out << "definition " << m->d_name << endl << endl;

    bool found = false;
    level++;
    foreach( CodeModel::Element* e, m->d_elems )
    {
        if( e->d_kind == CodeModel::Element::Constant )
        {
            if( !found )
            {
                out << ind() << "const" << endl;
                level++;
                found = true;
            }
            out << ind() << escapedIdent(m,e->d_name) << " = " << e->d_const.toString() << endl;
        }
    }
    if( found )
    {
        out << endl;
        level--;
    }
    level--;

    found = false;
    level++;
    foreach( CodeModel::Type* t, m->d_types )
    {
        if( !t->d_name.isEmpty() )
        {
            if( !found )
            {
                out << ind() << "type" << endl;
                level++;
                found = true;
            }
            out << ind() << escapedIdent(m,t->d_name) << " = ";
            type(m,t);
            out << endl;
        }
    }
    if( found )
    {
        out << endl;
        level--;
    }
    level--;

    found = false;
    level++;
    foreach( CodeModel::Element* e, m->d_elems )
    {
        if( e->d_kind == CodeModel::Element::Variable )
        {
            if( !found )
            {
                out << ind() << "var" << endl;
                level++;
                found = true;
            }
            out << ind() << escapedIdent(m,e->d_name) << ": ";
            type(m,e->d_type);
            out << endl;
        }
    }
    level--;
    if( found )
    {
        out << endl;
        level--;
    }

    found = false;
    level++;
    foreach( CodeModel::Element* e, m->d_elems )
    {
        if( e->d_kind == CodeModel::Element::StubProc )
        {
            found = true;
            out << ind() << "proc " << escapedIdent(m,e->d_name) << "(";
            for( int i = 0; i < e->d_vals.size(); i++ )
            {
                if( i != 0 )
                    out << "; ";
                out << escapedIdent(m,e->d_vals[i]->d_name) << ": ";
                type(m,e->d_vals[i]->d_type);
            }
            out << ")";
            if( e->d_type )
            {
                out << ": ";
                type(m,e->d_type);
            }
            out << endl;
        }
    }
    level--;
    if( found )
        out << endl;


    out << "end " << m->d_name << endl;
}

void ObxGen::importList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() > 1 );
    print("import ", st->d_children.first() );
    level++;
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        if( i > 1 )
            out << ", ";
        import(u, st->d_children[i]);
    }
    level--;
}

void ObxGen::import(const CodeModel::Unit* u, SynTree* st)
{
    switch( st->d_children.size() )
    {
    case 3:
        ident(u,st->d_children.first() );
        out << ":= ";
        ident(u,st->d_children.last() );
        break;
    case 1:
        ident(u,st->d_children.first() );
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

void ObxGen::ident(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_tok.d_type == Tok_ident );

    QByteArray id = st->d_tok.d_val;

    id = escapedIdent(u,id);

    print(id,st);
}

void ObxGen::declarationSequence(const CodeModel::Unit* u, SynTree* st)
{
    int i = 0;
    const bool moduleLevel = dynamic_cast<const CodeModel::Procedure*>(u) == 0;
    if( !moduleLevel )
        level++;
    while( i < st->d_children.size() )
    {
        bool first = true;
        switch( st->d_children[i]->d_tok.d_type )
        {
        case Tok_CONST:
            print("const ",st->d_children[i++]);
            level++;
            if( nlAfterDeclHeader && i < st->d_children.size() )
                assureNl(st->d_children[i]);
            first = true;
            while( i < st->d_children.size() && st->d_children[i]->d_tok.d_type == SynTree::R_ConstDeclaration )
            {
                if( !first )
                {
                    if( nlPerDecl )
                        assureNl(st->d_children[i]);
                    else
                        semi(st->d_children[i]);
                }
                first = false;
                constDeclaration(u,st->d_children[i++]);
            }
            level--;
            break;
        case Tok_TYPE:
            print("type ",st->d_children[i++]);
            level++;
            if( nlAfterDeclHeader && i < st->d_children.size() )
                assureNl(st->d_children[i]);
            while( i < st->d_children.size() && st->d_children[i]->d_tok.d_type == SynTree::R_TypeDeclaration )
            {
                if( !first )
                {
                    if( nlPerDecl )
                        assureNl(st->d_children[i]);
                    else
                        semi(st->d_children[i]);
                }
                first = false;
                typeDeclaration(u,st->d_children[i++]);
            }
            level--;
            break;
        case Tok_VAR:
            print("var ",st->d_children[i++]);
            level++;
            if( nlAfterDeclHeader && i < st->d_children.size() )
                assureNl(st->d_children[i]);
            while( i < st->d_children.size() && st->d_children[i]->d_tok.d_type == SynTree::R_VariableDeclaration )
            {
                if( !first )
                {
                    if( nlPerDecl )
                        assureNl(st->d_children[i]);
                    else
                        semi(st->d_children[i]);
                }
                first = false;
                variableDeclaration(u,st->d_children[i++]);
            }
            level--;
            break;
        case SynTree::R_ProcedureDeclaration:
            procedureDeclaration(u,st->d_children[i++]);
            break;
        case SynTree::R_ProcedureHeading:
            procedureHeading(u,st->d_children[i++]);
            break;
#ifdef OB_BBOX
        case SynTree::R_MethAttributes:
            // ignore
            i++;
            break;
#endif
        default:
            Q_ASSERT(false);
            break;
        }
    }
    if( !moduleLevel )
        level--;
}

void ObxGen::declarationSequence2(const CodeModel::Unit* u, SynTree* st)
{
    declarationSequence(u,st);
}

void ObxGen::constDeclaration(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 3 );
    identdef(u,st->d_children.first() );
    out << " = ";
    constExpression(u, st->d_children.last() );
}

void ObxGen::typeDeclaration(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 3 );
    identdef( u, st->d_children.first() );
    print( " = " );
    type( u, st->d_children.last() );
}

void ObxGen::variableDeclaration(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 2 ); // ':' is transparent
    identList( u, st->d_children.first() );
    print( ": " );
    type( u, st->d_children.last() );
}

void ObxGen::statementSequence(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_StatementSequence );
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        if( st->d_children[i]->d_tok.d_type == SynTree::R_statement )
        {
            if( i != 0 )
            {
                if( nlPerStat )
                    assureNl(st->d_children[i]);
                else
                    semi( st->d_children[i] );
            }
            statement( u, st->d_children[i] );
        }
    }
}

void ObxGen::procedureDeclaration(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 2 && st->d_tok.d_type == SynTree::R_ProcedureDeclaration );
    if( st->d_children.first()->d_tok.d_type == Tok_PROCEDURE )
    {
        switch( st->d_children[1]->d_tok.d_type )
        {
        case Tok_Hat:
            skipTo( st->d_children.last() );
            return; // forward declaration, ignored
        case Tok_Minus:
            print( "proc ", st->d_children.first() );
            break;
        default:
            Q_ASSERT(false);
        }
        const CodeModel::Procedure* p = findProc( u, st );

        for( int i = 2; i < st->d_children.size(); i++ )
        {
            switch( st->d_children[i]->d_tok.d_type )
            {
            case SynTree::R_Receiver:
                receiver( p, st->d_children[i] );
                break;
            case SynTree::R_identdef:
                identdef( u, st->d_children[i] );
                break;
            case SynTree::R_FormalParameters:
                formalParameters( p, st->d_children[i] );
                break;
            case SynTree::R_literal:
#ifdef OB_BBOX
            case SynTree::R_MethAttributes:
#endif
                break; // ignore
            default:
                Q_ASSERT( false );
            }
        }
        print( " end" );
    }
#ifdef OB_BBOX
    else
    {
        const CodeModel::Procedure* p = procedureHeading( u, st->d_children.first() );
        int off = 1;
        QByteArrayList attrs;
        if( st->d_children[off]->d_tok.d_type == Tok_ident )
        {
            attrs << st->d_children[off]->d_tok.d_val.toLower();
            off++;
        }
        switch( st->d_children[off]->d_tok.d_type )
        {
        case Tok_ABSTRACT:
        case Tok_EMPTY:
            attrs << QByteArray(tokenTypeString(st->d_children[off]->d_tok.d_type)).toLower();
            print(" end");
            if( !attrs.isEmpty() )
            {
                print(" // ");
                print( attrs.join(' ') );
            }
            break;
        case Tok_integer:
            attrs << st->d_children[off++]->d_tok.d_val;
            for( int i = off; i < st->d_children.size(); i++ )
                attrs << st->d_children[i]->d_tok.d_val;
            print(" end");
            if( !attrs.isEmpty() )
            {
                print(" // [code] ");
                print( attrs.join(' ') );
            }
            break;
        case Tok_EXTENSIBLE:
            attrs << QByteArray(tokenTypeString(st->d_children[off++]->d_tok.d_type)).toLower();
            if( !attrs.isEmpty() )
            {
                print(" // ");
                print( attrs.join(' ') );
            }
            Q_ASSERT( off < st->d_children.size() );
            assureNl( st->d_children[off]);
            procedureBody( p, st->d_children[off++] );
            Q_ASSERT( off < st->d_children.size() );
            ident( u, st->d_children[off] );
            break;
        case SynTree::R_ProcedureBody:
            if( !attrs.isEmpty() )
            {
                print(" // ");
                print( attrs.join(' ') );
            }
            Q_ASSERT( off < st->d_children.size() );
            assureNl( st->d_children[off]);
            procedureBody( p, st->d_children[off++] );
            Q_ASSERT( off < st->d_children.size() );
            ident( u, st->d_children[off] );
            break;
        default:
            Q_ASSERT( false );
        }
    }
#else
    else
    {
        for( int i = 0; i < st->d_children.size(); i++ )
        {
            switch( st->d_children[i]->d_tok.d_type )
            {
            case SynTree::R_ProcedureHeading:
                procedureHeading( u, st->d_children[i] );
                break;
            case SynTree::R_ProcedureBody:
                procedureBody( u, st->d_children[i] );
                break;
            case Tok_ident:
                ident( u, st->d_children[i] );
                break;
            default:
                Q_ASSERT( false );
            }
        }
    }
#endif
}

const CodeModel::Procedure*ObxGen::findProc(const CodeModel::Unit* u, SynTree* st)
{
    SynTree* identDef = findFirstChild( st, SynTree::R_identdef );
    Q_ASSERT( identDef && !identDef->d_children.isEmpty() && identDef->d_children.first()->d_tok.d_type == Tok_ident );
    SynTree* id = identDef->d_children.first();
    foreach( CodeModel::Procedure* p, u->d_procs )
    {
        if( p->d_id == id )
            return p;
    }
    Q_ASSERT( false );
    return 0;
}

const CodeModel::Procedure* ObxGen::procedureHeading(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_ProcedureHeading );
    const CodeModel::Procedure* p = findProc(u,st);
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* first = st->d_children[i];
        switch( first->d_tok.d_type )
        {
        case Tok_PROCEDURE:
        case Tok_PROC:
            print("proc ",first);
            break;
        case Tok_Star:
        case Tok_Plus:
            break; // ignore
#ifdef OB_BBOX
        case SynTree::R_SysFlag:
        case SynTree::R_SysString:
        case Tok_Lbrack:
        case Tok_Rbrack:
            break; // ignore
#endif
        case SynTree::R_Receiver:
            receiver(p,first);
            break;
        case SynTree::R_identdef:
            identdef(u,first);
            break;
        case SynTree::R_FormalParameters:
            formalParameters(p,first);
            break;
        default:
            Q_ASSERT(false);
        }
    }
    return p;
}

void ObxGen::identdef(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    ident(u,st->d_children.first());
    if( st->d_children.size() > 1 )
        print( st->d_children[1] );
}

void ObxGen::constExpression(const CodeModel::Unit* u, SynTree* st)
{
    // transparent
    expression(u,st);
}

void ObxGen::expression(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st && !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_expression );
    simpleExpression(u,st->d_children.first() );
    if( st->d_children.size() >= 3 )
    {
        space();
        Q_ASSERT( !st->d_children[1]->d_children.isEmpty() );
        print( st->d_children[1]->d_children.first(), true );
        space();
        simpleExpression(u,st->d_children[2]);
    }
}

void ObxGen::simpleExpression(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 1 && st->d_tok.d_type == SynTree::R_SimpleExpression );
    int off = 0;
    if( st->d_children.first()->d_tok.d_type == Tok_Plus || st->d_children.first()->d_tok.d_type == Tok_Minus )
    {
        off++;
        print( st->d_children.first() );
    }
    term( u, st->d_children[off++] );
    for( int i = off; i < st->d_children.size(); i += 2 )
    {
        space();
        Q_ASSERT( !st->d_children[i]->d_children.isEmpty() );
        print( st->d_children[i]->d_children.first(), true );
        space();
        term( u, st->d_children[i+1] );
    }
}

void ObxGen::term(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 1 && st->d_tok.d_type == SynTree::R_term );
    factor( u, st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i += 2 )
    {
        space();
        Q_ASSERT( !st->d_children[i]->d_children.isEmpty() );
        print( st->d_children[i]->d_children.first(), true );
        space();
        factor( u, st->d_children[i+1] );
    }
}

void ObxGen::factor(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 1 && st->d_tok.d_type == SynTree::R_factor );
    switch( st->d_children.first()->d_tok.d_type )
    {
    case SynTree::R_literal:
        literal( u, st->d_children.first() );
        break;
    case SynTree::R_variableOrFunctionCall:
        variableOrFunctionCall( u, st->d_children.first() );
        break;
    case Tok_Lpar:
        Q_ASSERT( st->d_children.size() == 3 );
        print( st->d_children[0] );
        expression( u, st->d_children[1] );
        print( st->d_children[2] );
        break;
    case Tok_Tilde:
        Q_ASSERT( st->d_children.size() == 2 );
        print( st->d_children[0] );
        factor( u, st->d_children[1] );
        break;
    default:
        qDebug() << SynTree::rToStr( st->d_children.first()->d_tok.d_type );
        Q_ASSERT( false );
    }
}

void ObxGen::literal(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_literal );
    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_number:
        Q_ASSERT( !first->d_children.isEmpty() );
        print( first->d_children.first(), true );
        break;
    case Tok_string:
        print( first );
        break;
    case Tok_hexstring:
        print( first, true );
        break;
    case Tok_hexchar:
        print( first, true );
        break;
    case Tok_NIL:
        print("nil", first);
        break;
    case SynTree::R_set:
        set(u,first);
        break;
#ifndef OB_BBOX
    case Tok_TRUE:
        print("true", st->d_children.first());
        break;
    case Tok_FALSE:
        print("false", st->d_children.first());
        break;
#endif
    default:
        Q_ASSERT( false );
    }
}

void ObxGen::variableOrFunctionCall(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_variableOrFunctionCall );
    designator( u, st->d_children.first() );
}

void ObxGen::designator(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_designator );
    qualident( u, st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
        selector(u, st->d_children[i] );
    // ignore '$' in case of BBOX
}

void ObxGen::set(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 2 );
    print( st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        SynTree* e = st->d_children[i];
        if( e->d_tok.d_type == SynTree::R_element )
        {
            if( i != 1 )
                print( ", " );
            element(u,e);
        }
    }
    print( st->d_children.last() );
}

void ObxGen::qualident(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_qualident );
    if( st->d_children.size() == 2 ) // dot is transparent
    {
        ident(u,st->d_children.first());
        print( "." );
        ident(u,st->d_children.last());
    }else
    {
        Q_ASSERT( st->d_children.size() == 1 );
        ident(u,st->d_children.first());
    }
}

void ObxGen::selector(const CodeModel::Unit* u, SynTree* st)
{
    if( st->d_children.isEmpty() )
        return; // happens in case of $ selector
    Q_ASSERT( !st->d_children.isEmpty() );
    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case Tok_ident: // dot is transparent
        Q_ASSERT( st->d_children.size() == 1 );
        print( "." );
        ident( u, st->d_children.last() );
        break;
    case Tok_Lbrack:
        Q_ASSERT( st->d_children.size() == 3 );
        print( first->d_tok.d_val, first );
        expList( u, st->d_children[1] );
        print( st->d_children.last() );
        break;
    case Tok_Lpar:
        Q_ASSERT( st->d_children.size() >= 2 );
        print( first );
        if( st->d_children.size() > 2 )
            expList( u, st->d_children[1] );
        print( st->d_children.last() );
        break;
    case Tok_Hat:
        print( first );
        break;
    default:
        qDebug() << SynTree::rToStr( st->d_children.first()->d_tok.d_type );
        Q_ASSERT( false );
    }
}

void ObxGen::expList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    expression(u, st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        print(", ");
        expression(u, st->d_children[i] );
    }
}

void ObxGen::type(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_type );
    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_NamedType:
        namedType( u, first );
        break;
    case SynTree::R_ArrayType:
        arrayType( u, first );
        break;
    case SynTree::R_RecordType:
        recordType( u, first );
        //newLine();
        break;
    case SynTree::R_PointerType:
        pointerType( u, first );
        break;
    case SynTree::R_ProcedureType:
        procedureType( u, first );
        break;
    default:
        Q_ASSERT( false );
    }
}

void ObxGen::type(const CodeModel::Unit* u, const CodeModel::Type* t)
{
    static const char* unknown = "UNKNOWN";
    if( t == 0 )
    {
        out << unknown;
        return;
    }
    if( t->isBasicType() )
    {
        if( t->d_kind == CodeModel::Type::NIL )
            out << unknown;
        else
            out << QByteArray(CodeModel::Type::s_kindName[t->d_kind]).toLower();
        return;
    }
    if( t->d_kind == CodeModel::Type::TypeRef )
    {
        qualident(u,t->d_st);
        return;
        /*
        const CodeModel::Type* b = t->d_type;
        if( b && b->isBasicType() )
            out << QByteArray(CodeModel::Type::s_kindName[b->d_kind]).toLower();
        else
        {
            CodeModel::Quali q = d_mdl->derefQualident( u, t->d_st );
            if( q.second.first )
            {
                if( q.first.first )
                    out << q.first.first->d_name << ".";
                if( q.second.first )
                    out << q.second.first->d_name;
            }else
                out << unknown;
        }
        return;
        */
    }

    if( t->d_kind == CodeModel::Type::Array )
    {
        out << "array ";
        if( t->d_st )
        {
            expression(u,t->d_st);
            out << " ";
        }
        out << "of ";
        if( t->d_type )
            type( u, t->d_type );
        else
            out << unknown;
        return;
    }

    if( t->d_kind == CodeModel::Type::Pointer )
    {
        out << "pointer to ";
        if( t->d_type )
            type(u, t->d_type);
        else
            out << unknown;
        return;
    }

    if( t->d_kind == CodeModel::Type::Record )
    {
        out << "record ";
        if( t->d_type )
        {
            out << "(";
            type(u,t->d_type);
            out << ")";
        }
        if( !t->d_vals.isEmpty() )
        {
            level++;
            out << endl;
            foreach( const CodeModel::Element* e, t->d_vals )
            {
                out << ind() << escapedIdent(u,e->d_name) << ": ";
                type(u,e->d_type);
                out << endl;
            }
            level--;
            out << ind();
        }
        out << "end";
        return;
    }

    out << unknown;
}

void ObxGen::identList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    identdef( u, st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        print(", "); // ',' is transparent
        identdef( u, st->d_children[i] );
    }
}

void ObxGen::namedType(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_NamedType );
    qualident( u, st->d_children.first() );
}

void ObxGen::arrayType(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_ArrayType );
    print( "array ", st->d_children.first());
    // ignore SysFlag
    if( SynTree* ll = findFirstChild(st, SynTree::R_LengthList, 1 ) )
    {
        lengthList( u, ll );
        space();
    }
    print( "of " );
    type( u, st->d_children.last() );
}

void ObxGen::recordType(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() >= 2 && st->d_tok.d_type == SynTree::R_RecordType );
    SynTree* first = st->d_children.first();
#ifdef OB_BBOX
    switch( first->d_tok.d_type )
    {
    case Tok_ABSTRACT:
    case Tok_EXTENSIBLE:
    case Tok_LIMITED:
        print( "(* " );
        print( first, true );
        print( " *) " );
        first = st->d_children[1];
        break;
    }
#endif
    print( "record ", first );
    level++;
    if( SynTree* base = findFirstChild( st, SynTree::R_BaseType, 1 ) )
    {
        print("(",base);
        baseType(u,base);
        print(") ",base);
    }
    level++;
    if( SynTree* ff = findFirstChild( st, SynTree::R_FieldListSequence, 1 ) )
    {
        fieldListSequence(u,ff);
        space();
    }
    level--;
    print( "end ", st->d_children.last() );
    level--;
}

void ObxGen::pointerType(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_PointerType );
    // ignore SysFlag
    print( "pointer to ", st->d_children.first());
    type( u, st->d_children.last() );
}

void ObxGen::procedureType(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_PROCEDURE:
        case Tok_PROC:
            print( "proc ", c );
            break;
        case SynTree::R_FormalParameters:
            formalParameters(u,c);
            break;
#ifdef OB_BBOX
        case SynTree::R_SysFlag:
            break; // ignore
#endif
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::lengthList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    constExpression( u, st->d_children.first() ); // length is transparent
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        print( ", " ); // ',' is transparent
        constExpression( u, st->d_children[i] );
    }
}

void ObxGen::baseType(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    namedType( u, st->d_children.first() );
}

void ObxGen::fieldListSequence(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    fieldList( u, st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        semi( st->d_children[i] );
        fieldList( u, st->d_children[i] );
    }
}

void ObxGen::fieldList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 2 ); // ':' is transparent
    identList( u, st->d_children.first() );
    print( ": " );
    type( u, st->d_children.last() );
}

void ObxGen::element(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    expression( u, st->d_children.first() );
    if( st->d_children.size() > 1 )
    {
        print( st->d_children[1] );
        expression( u, st->d_children.last() );
    }
}

void ObxGen::receiver(const CodeModel::Unit* u, SynTree* st)
{
    bool colonSent = false;
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_VAR:
        case Tok_IN:
            print( c, true );
            space();
            break;
        case Tok_ident:
            ident(u,c);
            if( !colonSent )
            {
                colonSent = true;
                print( ": " );
            }
            break;
        case Tok_Lpar:
        case Tok_Rpar:
            print( c );
            break;
        default:
            Q_ASSERT( false );
        }
    }
    space();
}

void ObxGen::formalParameters(const CodeModel::Unit* u, SynTree* st)
{
    level++;
    bool firstFp = true;
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case SynTree::R_FPSection:
            if( !firstFp )
                semi( c );
            fpSection(u,c);
            firstFp = false;
            break;
        case SynTree::R_type:
            print( ": " );
#ifdef OB_OBN2
            type(u,c);
#else
            namedType(u,c);
#endif
            break;
        case Tok_Lpar:
        case Tok_Rpar:
            print( c );
            break;
        default:
            Q_ASSERT( false );
        }
    }
    level--;
}

void ObxGen::procedureBody(const CodeModel::Unit* u, SynTree* st)
{
    bool leveled = false;
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_ProcedureBody );
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_BEGIN:
            print( "begin ", c );
            level++;
            leveled = true;
            Q_ASSERT( i+1 < st->d_children.size() );
            if( ifStatAfterBegin(st->d_children[i+1]) )
                assureNl(st->d_children[i+1]);
            break;
        case Tok_END:
            if( leveled )
                level--;
            if( nlBeforeEnd )
                assureNl(c);
            print( "end ", c );
            break;
        case SynTree::R_DeclarationSequence:
            declarationSequence(u,c);
            break;
        case SynTree::R_StatementSequence:
            statementSequence(u,c);
            break;
        case SynTree::R_ReturnStatement:
            returnStatement(u,c);
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::fpSection(const CodeModel::Unit* u, SynTree* st)
{
    bool firstId = true;
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_VAR:
        case Tok_IN:
            print( c, true );
            space();
            break;
#ifdef OB_BBOX
        case Tok_OUT:
            print( "var ", c );
            break;
        case SynTree::R_SysFlag:
            break; // ignore
#endif
        case Tok_ident:
            if( !firstId )
                print( ", " );
            ident(u,c);
            firstId = false;
            break;
        case SynTree::R_FormalType:
            print( ": " );
            formalType(u,c);
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::formalType(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
#ifdef OB_OBN2
        case SynTree::R_type:
            type(u,c);
            break;
#else
        case Tok_ARRAY:
        case Tok_OF:
            print( c, true );
            space();
            break;
        case SynTree::R_NamedType:
            namedType(u,c);
            break;
#endif
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::returnStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_RETURN:
            print(c,true);
            space();
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::statement(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() && st->d_tok.d_type == SynTree::R_statement );
    SynTree* first = st->d_children.first();
    switch( first->d_tok.d_type )
    {
    case SynTree::R_assignmentOrProcedureCall:
    case SynTree::R_assignment_:
        assignment(u,first);
        break;
    case SynTree::R_ProcedureCall_:
        procedureCall(u,first);
        break;
    case SynTree::R_IfStatement:
        ifStatement(u,first);
        break;
    case SynTree::R_CaseStatement:
        caseStatement(u,first);
        break;
#ifdef OB_OBN2
    case SynTree::R_WithStatement:
        withStatement(u,first);
        break;
    case SynTree::R_LoopStatement:
        loopStatement(u,first);
        break;
    case SynTree::R_ExitStatement:
        exitStatement(u,first);
        break;
    case SynTree::R_ReturnStatement:
        returnStatement(u,first);
        break;
#endif
    case SynTree::R_WhileStatement:
        whileStatement(u,first);
        break;
    case SynTree::R_RepeatStatement:
        repeatStatement(u,first);
        break;
    case SynTree::R_ForStatement:
        forStatement(u,first);
        break;
    default:
        qDebug() << SynTree::rToStr(first->d_tok.d_type);
        Q_ASSERT(false);
    }
}

void ObxGen::assignment(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    designator( u, st->d_children.first() );
    if( st->d_children.size() > 1 )
    {
        space();
        print( st->d_children[1] );
        space();
        level++;
        expression( u, st->d_children.last() );
        level--;
    }
}

void ObxGen::procedureCall(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    designator( u, st->d_children.first() );
    if( st->d_children.size() == 2 )
    {
        level++;
        actualParameters(u, st->d_children.last() );
        level--;
    }
}

void ObxGen::actualParameters(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_Lpar:
        case Tok_Rpar:
            print(c);
            break;
        case SynTree::R_ExpList:
            expList(u,c);
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::ifStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_IF:
            print(c,true);
            space();
            break;
        case Tok_THEN:
            print(c,true);
            break;
        case Tok_END:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_ElsifStatement:
            elsifStatement(u,c);
            break;
        case SynTree::R_ElseStatement:
            elseStatement(u,c);
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            level--;
            space();
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::caseStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_CASE:
            print(c,true);
            space();
            break;
        case Tok_OF:
            print(c,true);
            space();
            level++;
            Q_ASSERT( i + 1 < st->d_children.size() );
            if( nlAfterBegin )
                assureNl(st->d_children[i+1]);
            break;
        case Tok_ELSE:
            level--;
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            level++;
            break;
        case Tok_Bar:
            if( nlAfterBegin )
                assureNl(c);
            print(c,true);
            space();
            break;
        case Tok_END:
            level--;
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_Case:
            case_(u,c);
            break;
        case SynTree::R_StatementSequence:
            // belongs to the ELSE part
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::withStatement(const CodeModel::Unit* u, SynTree* st)
{
#ifdef OB_OBN2
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_WithStatement );
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_WITH:
            print(c,true);
            space();
            break;
        case Tok_DO:
            print(c,true);
            space();
            break;
        case Tok_ELSE:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case Tok_Bar:
            print(c,true);
            space();
            break;
        case Tok_END:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_Guard:
        case 1: // TODO: this is unexpected behaviour, but seems to work; check
            guard(u,c);
            space();
            break;
        default:
            qDebug() << SynTree::rToStr(c->d_tok.d_type);
            Q_ASSERT( false );
        }
    }
#endif
}

void ObxGen::loopStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_LOOP:
            print(c,true);
            space();
            break;
        case Tok_END:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::exitStatement(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 1 );
    print( st->d_children.first(), true );
}

void ObxGen::whileStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_WHILE:
            print(c,true);
            space();
            break;
        case Tok_ELSIF:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case Tok_DO:
            print(c,true);
            space();
            break;
        case Tok_END:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_ElsifStatement2:
            elsifStatement(u,c);
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::repeatStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_REPEAT:
            print(c,true);
            space();
            break;
        case Tok_UNTIL:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::forStatement(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st && st->d_tok.d_type == SynTree::R_ForStatement );
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_FOR:
        case Tok_TO:
        case Tok_BY:
        case Tok_ColonEq:
            print(c,true);
            space();
            break;
        case Tok_DO:
            print(c,true);
            space();
            break;
        case Tok_END:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case Tok_ident:
            ident(u,c);
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            space();
            level--;
            break;
        default:
            qDebug() << SynTree::rToStr(c->d_tok.d_type);
            Q_ASSERT( false );
        }
    }
}

void ObxGen::elsifStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_ELSIF:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case Tok_THEN:
        case Tok_DO:
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        case SynTree::R_expression:
            level++;
            expression(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::elseStatement(const CodeModel::Unit* u, SynTree* st)
{
    for( int i = 0; i < st->d_children.size(); i++ )
    {
        SynTree* c = st->d_children[i];
        switch( c->d_tok.d_type )
        {
        case Tok_ELSE:
            if( nlBeforeEnd )
                assureNl(c);
            print(c,true);
            space();
            break;
        case SynTree::R_StatementSequence:
            level++;
            if( ifStatAfterBegin(c) )
                assureNl(c);
            statementSequence(u,c);
            space();
            level--;
            break;
        default:
            Q_ASSERT( false );
        }
    }
}

void ObxGen::case_(const CodeModel::Unit* u, SynTree* st)
{
    if( st->d_children.size() == 2 ) // ':' is transparent
    {
        caseLabelList(u,st->d_children.first());
        print(": ");
        level++;
        if( ifStatAfterBegin(st->d_children.last()) )
            assureNl(st->d_children.last());
        statementSequence(u,st->d_children.last());
        space();
        level--;
    }else if( st->d_children.isEmpty() )
        ; // NOP
    else
        Q_ASSERT(false);
}

void ObxGen::caseLabelList(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    labelRange(u,st->d_children.first() );
    for( int i = 1; i < st->d_children.size(); i++ )
    {
        print(", ");
        labelRange(u,st->d_children[i] );
    }
}

void ObxGen::labelRange(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
    label(u,st->d_children.first() );
    if( st->d_children.size() == 3 )
    {
        space();
        print( st->d_children[1] );
        space();
        label(u,st->d_children.last() );
    }
}

void ObxGen::label(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( !st->d_children.isEmpty() );
#ifdef OB_OBN2
    constExpression(u,st->d_children.first() );
#else
    SynTree* c = st->d_children.first();
    switch( c->d_tok.d_type )
    {
    case Tok_integer:
    case Tok_string:
        print( c );
        break;
    case Tok_hexchar:
    case Tok_hexstring:
        print( c, true );
        break;
    case SynTree::R_qualident:
        qualident(u,c);
        break;
    default:
        Q_ASSERT( false );
    }
#endif
}

void ObxGen::guard(const CodeModel::Unit* u, SynTree* st)
{
    Q_ASSERT( st->d_children.size() == 2 ); // ':' transparent
    qualident( u, st->d_children.first() );
    print(": ");
    qualident( u, st->d_children.last() );
}

QByteArray ObxGen::escapedIdent(const CodeModel::Unit* u, const QByteArray& in)
{
    bool keyword = false;

    QByteArray out = in;
    const CodeModel::NamedThing* n = u->findByName(out);
    if( n )
    {
        if( const CodeModel::Element* e = dynamic_cast<const CodeModel::Element*>( n ) )
        {
            if( ( e->d_kind >= CodeModel::Element::ABS && e->d_kind <= CodeModel::Element::FALSE ) ||
                    e->d_kind == CodeModel::Element::LED )
            {
                keyword = true;
                out = out.toLower();
            }
        }else if( const CodeModel::Type* t = dynamic_cast<const CodeModel::Type*>( n ) )
        {
            if( t->d_kind >= CodeModel::Type::BOOLEAN && t->d_kind <= CodeModel::Type::SET )
            {
                keyword = true;
                out = CodeModel::Type::s_kindName[t->d_kind]; // SHORTCHAR etc. mapped to CHAR type
                if( switchBBoxTypes )
                {
                    if( out == "SHORTREAL" )
                        out = "REAL";
                    else if( out == "REAL" )
                        out = "LONGREAL";
                    else if( out == "SHORTCHAR" )
                        out = "CHAR";
                    else if( !noWchar && out == "CHAR" )
                        out = "WCHAR";
                }
                out = out.toLower();
            }
        }
    }

    if( !keyword && reservedWords.contains(out) )
        out += "_";
    return out;
}

void ObxGen::print(const QByteArray& str, SynTree* curRowCol)
{
//    if( curRowCol && curRowCol->d_tok.d_sourcePath.endsWith("/Viewers.Mod") && curRowCol->d_tok.d_lineNr == 23 )
//        qDebug() << "hit";

    if( curRowCol )
    {
        printComments(curRowCol);
        if( prevRow < curRowCol->d_tok.d_lineNr )
        {
            const int toInsert = curRowCol->d_tok.d_lineNr - prevRow;
            for( int i = 0; i < toInsert; i++ )
                out << endl << ind();
            prevRow = curRowCol->d_tok.d_lineNr;
            rowPrinted = false;
        }
        prevSym = curRowCol;
    }
    out << str;
    rowPrinted = true;
}

void ObxGen::print(SynTree* st, bool toLower )
{
    Q_ASSERT( st );
    QByteArray str = st->d_tok.d_val;
    if( str.isEmpty() )
        str = tokenTypeString(st->d_tok.d_type);
    if( toLower )
        print( str.toLower(), st );
    else
        print( str, st );
}

int ObxGen::printComment( const QByteArray& str, bool mayEndOfLine )
{
    QByteArray stripped = str.trimmed();
    stripped = stripped.mid(2,stripped.size() - 4).trimmed();
    if( stripped.startsWith('*') && stripped.endsWith('*') )
        stripped = stripped.mid(1,stripped.size()-2).trimmed(); // cover (** xxx **) comments
    const QByteArrayList lines = stripped.split('\n');
    if( lines.size() == 1 && mayEndOfLine )
    {
        out << "// " << lines.first();
        return 1;
    }else
    {
        out << "(* ";
        for( int i = 0; i < lines.size(); i++ )
        {
            if( i != 0 )
                out << endl << ind() << "   ";
            out << lines[i].trimmed();
        }
        out << " *)";
        return lines.size();
    }
}

void ObxGen::printComments(SynTree* st)
{
    if( d_cmts.isEmpty() )
        return;
    Q_ASSERT( d_nextCmt >= d_cmts.size() || d_cmts[d_nextCmt].d_lineNr >= prevRow );

    if( st == 0 || prevRow < st->d_tok.d_lineNr )
    {
        // finish prev line
        while( d_cmts.size() > d_nextCmt && d_cmts[d_nextCmt].d_lineNr == prevRow )
        {
            if( rowPrinted )
                space();
            printComment( d_cmts[d_nextCmt].d_val, true );
            d_nextCmt++;
        }
    }

    if( st == 0 )
        return;

    const int curRow = st->d_tok.d_lineNr;
    const int curCol = st->d_tok.d_colNr;

    Q_ASSERT( prevRow <= curRow );

    // consider comments between prev and cur row
    while( d_cmts.size() > d_nextCmt && d_cmts[d_nextCmt].d_lineNr < curRow )
    {
        const int toInsert = d_cmts[d_nextCmt].d_lineNr - prevRow;
        for( int i = 0; i < toInsert; i++ )
            out << endl << ind();
        const int lines = printComment( d_cmts[d_nextCmt].d_val, true );
        prevRow = d_cmts[d_nextCmt].d_lineNr + lines - 1;
        rowPrinted = true;
        d_nextCmt++;
    }

    // consider line in progress
    while( d_cmts.size() > d_nextCmt && d_cmts[d_nextCmt].d_lineNr == curRow && d_cmts[d_nextCmt].d_colNr < curCol )
    {
        printComment( d_cmts[d_nextCmt].d_val, false );
        d_nextCmt++;
    }
}

void ObxGen::newLine(bool comment)
{
    if( comment )
        printComments();
    out << endl << ind();
    // not yet supported: prevRow++;
    // need something like "assertMinLn(x)" which checks the existing number of Ln between given symbols and adds only if needed
}

void ObxGen::assureNl(SynTree* next, quint8 soll, bool comment)
{
    if( prevSym == 0 || next == 0 || soll == 0 )
        return;
    const int ist = next->d_tok.d_lineNr - prevSym->d_tok.d_lineNr;
    const int todo = soll - ist;
    if( comment && todo > 0 )
        printComments();
    for( int i = 0; i < todo; i++ )
        out << endl << ind();
}

void ObxGen::skipTo(SynTree* to)
{
    Q_ASSERT( to != 0 );
    printComments(to);
    prevSym = to;
    prevRow = to->d_tok.d_lineNr;
}

bool ObxGen::ifStatAfterBegin(SynTree* statSeq)
{
    if( !nlAfterBegin )
        return false;
    Q_ASSERT( statSeq && statSeq->d_tok.d_type == SynTree::R_StatementSequence );
    return !statSeq->d_children.isEmpty();
}




