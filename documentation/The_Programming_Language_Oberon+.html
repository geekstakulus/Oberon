<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Asciidoctor 1.5.4">
  <meta name="author" content="Rochus Keller">
  <title>The Programming Language Oberon+</title>
  <link rel="stylesheet" href="https://asciidoclive.com/assets/asciidoctor.js/css/asciidoctor.css">
</head>

<body class="article toc2 toc-left">
  <div id="header">
    <h1>The Programming Language Oberon+</h1>
    <div class="details">
      <span id="author" class="author">Rochus Keller</span><br>
      <span id="email" class="email"><a href="mailto:me@rochus-keller.ch">me@rochus-keller.ch</a></span><br>
      <span id="revdate">2021-07-09</span>
      <br><span id="revremark">work in progress</span>
    </div>
    <div id="toc" class="toc2">
      <div id="toctitle">Table of Contents</div>
      <ul class="sectlevel1">
        <li><a href="#_introduction">1. Introduction</a></li>
        <li><a href="#_syntax">2. Syntax</a></li>
        <li><a href="#_vocabulary_and_representation">3. Vocabulary and Representation</a>
          <ul class="sectlevel2">
            <li><a href="#_identifiers">3.1. Identifiers</a></li>
            <li><a href="#_numbers">3.2. Numbers</a></li>
            <li><a href="#_characters">3.3. Characters</a></li>
            <li><a href="#_strings">3.4. Strings</a></li>
            <li><a href="#_operators_and_delimiters">3.5. Operators and Delimiters</a></li>
            <li><a href="#_reserved_words">3.6. Reserved Words</a></li>
            <li><a href="#_comments">3.7. Comments</a></li>
          </ul>
        </li>
        <li><a href="#_declarations_and_scope_rules">4. Declarations and scope rules</a></li>
        <li><a href="#_constant_declarations">5. Constant declarations</a></li>
        <li><a href="#_type_declarations">6. Type declarations</a>
          <ul class="sectlevel2">
            <li><a href="#_basic_types">6.1. Basic types</a></li>
            <li><a href="#_array_types">6.2. Array types</a></li>
            <li><a href="#_record_types">6.3. Record types</a></li>
            <li><a href="#_pointer_types">6.4. Pointer types</a></li>
            <li><a href="#_procedure_types">6.5. Procedure types</a></li>
            <li><a href="#_enumeration_types">6.6. Enumeration types</a></li>
          </ul>
        </li>
        <li><a href="#_variable_declarations">7. Variable declarations</a></li>
        <li><a href="#_expressions">8. Expressions</a>
          <ul class="sectlevel2">
            <li><a href="#_operands">8.1. Operands</a></li>
            <li><a href="#_operators">8.2. Operators</a></li>
          </ul>
        </li>
        <li><a href="#_statements">9. Statements</a>
          <ul class="sectlevel2">
            <li><a href="#_statement_sequences">9.1. Statement sequences</a></li>
            <li><a href="#_assignments">9.2. Assignments</a></li>
            <li><a href="#_procedure_calls">9.3. Procedure calls</a></li>
            <li><a href="#_if_statements">9.4. If statements</a></li>
            <li><a href="#_case_statements">9.5. Case statements</a></li>
            <li><a href="#_while_statements">9.6. While statements</a></li>
            <li><a href="#_repeat_statements">9.7. Repeat statements</a></li>
            <li><a href="#_for_statements">9.8. For statements</a></li>
            <li><a href="#_loop_statements">9.9. Loop statements</a></li>
            <li><a href="#_return_and_exit_statements">9.10. Return and exit statements</a></li>
            <li><a href="#_with_statements">9.11. With statements</a></li>
          </ul>
        </li>
        <li><a href="#_procedure_declarations">10. Procedure declarations</a>
          <ul class="sectlevel2">
            <li><a href="#_formal_parameters">10.1. Formal parameters</a></li>
            <li><a href="#_type_bound_procedures">10.2. Type-bound procedures</a></li>
            <li><a href="#_predeclared_procedures">10.3. Predeclared procedures</a></li>
          </ul>
        </li>
        <li><a href="#_modules">11. Modules</a>
          <ul class="sectlevel2">
            <li><a href="#_generics">11.1. Generics</a></li>
            <li><a href="#_definitions">11.2. Definitions</a></li>
          </ul>
        </li>
        <li><a href="#_definition_of_terms">Appendix A: Definition of terms</a></li>
        <li><a href="#_syntax_of_oberon">Appendix B: Syntax of Oberon+</a></li>
        <li><a href="#_references">Appendix C: References</a></li>
      </ul>
    </div>
  </div>
  <div id="content">
    <div id="preamble">
      <div class="sectionbody">
        <div class="paragraph">
          <p>Based on work by Niklaus Wirth and Hanspeter Mössenböck (<a href="#Wi16">[Wi16]</a>,
            <a href="#Mo91">[Mo91]</a>).</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_introduction">1. Introduction</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Oberon+ (i.e. <em>Oberon with extensions</em>, abbreviated <strong>OBX</strong>,
            pronounced <em>obex</em>) is a general-purpose, procedural and object-oriented
            programming language in the tradition of Oberon-07 <a href="#Wi16">[Wi16]</a>            and Oberon-2 <a href="#Mo91">[Mo91]</a>.</p>
        </div>
        <div class="paragraph">
          <p>The most important features of Oberon+ are block structure, modularity,
            separate compilation, static typing with strong type checking, generic
            programming <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>,
            garbage collection, and type extension with type-bound procedures.</p>
        </div>
        <div class="paragraph">
          <p>A major design goal of Oberon in 1987 was to make the language as simple
            as possible <a href="#Wi87">[Wi87]</a>. Oberon+ follows the same goal,
            but taking into account the current state of the art. Backwards compatibility
            remains mostly ensured: a valid Oberon-2 or Oberon-07 program is generally
            also a valid Oberon+ program <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>.</p>
        </div>
        <div class="paragraph">
          <p>The language allows several simplifications compared to previous Oberon
            versions: keywords can be written in lower case, all semicolons are optional,
            and for some keywords there are shorter variants; a declaration sequence
            can contain more than one CONST, TYPE and VAR section in arbitrary order,
            interleaved with procedures.</p>
        </div>
        <div class="paragraph">
          <p>Furthermore, enumeration types (known as <em>scalar types</em> in Pascal
            <a href="#Wi73">[Wi73]</a>) have been added to the language. IN can be
            used instead of VAR for constant variable parameters.</p>
        </div>
        <div class="paragraph">
          <p>This report is not intended as a programmer&#8217;s tutorial. It is intentionally
            kept concise. Its function is to serve as a reference for programmers,
            implementors, and tutorial writers. What remains unsaid is mostly left
            so intentionally, either because it can be derived from stated rules
            of the language, or because it would require to commit the definition
            when a general commitment appears as unwise.</p>
        </div>
        <div id="obx-generics-example" class="listingblock">
          <div class="title">Listing 1. Oberon+ example featuring syntactic simplifications and type
            parameters</div>
          <div class="content">
            <pre class="highlight"><code class="language-oberon" data-lang="oberon">module Lists&lt;T&gt;
    type
        List*     = ^record
            value : T
            next  : List
        end

    proc (l : List) Add* (v : T)
    begin
    	new( l.next )
    	l.next.value := v
    end Add

    proc (l : List) Print()
    begin
    	println(l.value)
    end Print
end Lists

module ListTest
	import
		L := Lists&lt;integer&gt;
	var
		l := L.List
	begin
		new(l)
		l.value := 123
		l.Add(456)
		l.Print()
		l.next.Print()
end ListTest</code></pre>
          </div>
        </div>
        <div class="paragraph">
          <p>See <a href="#oberon-2-example">here</a> for more examples.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_syntax">2. Syntax</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>An extended Backus-Naur Formalism (EBNF) is used to describe the syntax
            of Oberon+:</p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Alternatives are separated by <strong>|</strong>.</p>
            </li>
            <li>
              <p>Brackets <strong>[</strong> and <strong>]</strong> denote optionality
                of the enclosed expression.</p>
            </li>
            <li>
              <p>Braces <strong>{</strong> and <strong>}</strong> denote its repetition
                (possibly 0 times).</p>
            </li>
            <li>
              <p>Syntactic entities (non-terminal symbols) are denoted by English words
                expressing their intuitive meaning.</p>
            </li>
            <li>
              <p>Symbols of the language vocabulary (terminal symbols) are denoted by
                strings enclosed in quotation marks or by words in capital letters.</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_vocabulary_and_representation">3. Vocabulary and Representation</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Oberon+ source code is a string of characters encoded using the UTF-8 variable-width
            encoding as defined in ISO/IEC 10646. Identifiers, numbers, operators,
            and delimiters are represented using the ASCII character set; strings
            and comments can be either represented in the ASCII, Latin-1 (as defined
            in ISO/IEC 8859-1) or the Unicode Basic Multilingual Plane (BMP, plane
            0, as defined in ISO/IEC 10646) character set.</p>
        </div>
        <div class="paragraph">
          <p>The following lexical rules apply: blanks and line breaks must not occur
            within symbols (except in comments, and blanks in strings); they are
            ignored unless they are essential to separate two consecutive symbols.
            Capital and lower-case letters are considered as distinct.</p>
        </div>
        <div class="sect2">
          <h3 id="_identifiers">3.1. Identifiers</h3>
          <div class="paragraph">
            <p>Identifiers are sequences of letters, digits and underscore. The first
              character must be a letter or an underscore.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ident  = ( letter | '_' ) { letter | digit | '_' }
letter = 'A' ... 'Z' | 'a' ... 'z'
digit  = '0' ... '9'</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>x
Scan
Oberon_2
_y
firstLetter</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_numbers">3.2. Numbers</h3>
          <div class="paragraph">
            <p>Numbers are (unsigned) integer or real constants. The type of an integer
              constant is the minimal type to which the constant value belongs (see
              <a href="#_basic_types">Basic types</a>). If the constant is specified
              with the suffix <code>H</code> (or <code>h</code>), the representation
              is hexadecimal otherwise the representation is decimal.</p>
          </div>
          <div class="paragraph">
            <p>A real number always contains a decimal point and at least one digit
              before the point. Optionally it may also contain a decimal scale factor.
              The letter <code>E</code> or <code>D</code> (or <code>e</code> or <code>d</code>)
              means <em>times ten to the power of</em>. A real number is of type
              <code>REAL</code>, unless it has a scale factor containing the letter
              D. In this case it is of type <code>LONGREAL</code>.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>number   = integer | real
integer  = digit {digit} | digit {hexDigit} ('H' | 'h')
real     = digit {digit} '.' {digit} [Exponent]
Exponent = ('E' | 'e' | 'D' | 'd') ['+' | '-'] digit {digit}
hexDigit = digit | 'A' ... 'F' | 'a' ... 'f'
digit    = '0' ... '9'</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>1234
0dh              0DH
12.3
4.567e8          4.567E8
0.57712566d-6    0.57712566D-6</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_characters">3.3. Characters</h3>
          <div class="paragraph">
            <p>Character constants are denoted by the ordinal number of the character
              in hexadecimal notation followed by the letter <code>X</code> (or <code>x</code>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>character = digit {hexDigit} ('X' | 'x')</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>A character is either encoded as a 8-bit code value using the ISO/IEC
              8859-1 Latin-1 encoding scheme or a 16-bit code value using the Unicode
              BMP scheme.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_strings">3.4. Strings</h3>
          <div class="paragraph">
            <p>Strings are sequences of characters enclosed in single (') or double
              (") quote marks. The opening quote must be the same as the closing
              quote and must not occur within the string. The number of characters
              in a string is called its length. A string of length 1 can be used
              wherever a character constant is allowed and vice versa.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>string = ''' {character} ''' | '"' {character} '"'</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>'Oberon'
"Don't worry!"
'x'</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_operators_and_delimiters">3.5. Operators and Delimiters</h3>
          <div class="paragraph">
            <p>Operators and delimiters are the special characters, or character pairs
              listed below.</p>
          </div>
          <table class="tableblock frame-all grid-all spread">
            <colgroup>
              <col style="width: 16.6666%;">
              <col style="width: 16.6666%;">
              <col style="width: 16.6666%;">
              <col style="width: 16.6666%;">
              <col style="width: 16.6666%;">
              <col style="width: 16.667%;">
            </colgroup>
            <tbody>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">-</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">,</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">;</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">:</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">:=</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">.</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">..</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">(</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">)</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">[</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">]</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">{</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">}</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">*</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">/</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">#</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">^</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">+</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">&lt;=</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">=</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">&gt;=</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">|</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">~</p>
                </td>
                <td class="tableblock halign-left valign-top"></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="sect2">
          <h3 id="_reserved_words">3.6. Reserved Words</h3>
          <div class="paragraph">
            <p>The reserved words consist of either all capital or all lower case letters
              and cannot be used as identifiers. All words listed below are reserved
              (only capital letter versions shown).</p>
          </div>
          <table class="tableblock frame-all grid-all spread">
            <colgroup>
              <col style="width: 20%;">
              <col style="width: 20%;">
              <col style="width: 20%;">
              <col style="width: 20%;">
              <col style="width: 20%;">
            </colgroup>
            <tbody>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">ARRAY</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">BEGIN</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">BY</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">CASE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">CONST</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">DEFINITION</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">DIV</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">DO</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">ELSE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">ELSIF</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">END</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">EXIT</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">FALSE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">FOR</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">IF</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">IMPORT</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">IN</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">IS</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">LOOP</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">MOD</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">MODULE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">NIL</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">OF</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">OR</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">POINTER</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">PROC</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">PROCEDURE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">RECORD</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">REPEAT</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">RETURN</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">THEN</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">TO</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">TRUE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">TYPE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">UNTIL</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">VAR</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">WHILE</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">WITH</p>
                </td>
                <td class="tableblock halign-left valign-top"></td>
                <td class="tableblock halign-left valign-top"></td>
              </tr>
            </tbody>
          </table>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  WITH, LOOP and EXIT are Oberon-2 reserved words not present in Oberon-07. In contrast
                  TRUE and FALSE are Oberon-07 and Oberon+ keywords but just predeclared
                  identifiers in Oberon-2. DEFINITION and PROC are Oberon+ reserved
                  words not present in previous Oberon versions. All lower-case versions
                  are only reserved words in Oberon+. The compiler is supposed to
                  offer a dedicated Oberon-2 and Oberon-07 compatibility mode to
                  support legacy code with reserved word collisions.
                </td>
              </tr>
            </table>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_comments">3.7. Comments</h3>
          <div class="paragraph">
            <p>Comments are arbitrary character sequences opened by the bracket <code>(*</code>              and closed by <code>*)</code>. Comments may be nested. They do not
              affect the meaning of a program. Oberon+ also supports line comments;
              text starting with <code>//</code> up to a line break is considered
              a comment.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_declarations_and_scope_rules">4. Declarations and scope rules</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Every identifier occurring in a program must be introduced by a declaration,
            unless it is a predeclared identifier. Declarations also specify certain
            permanent properties of an object, such as whether it is a constant,
            a type, a variable, or a procedure. The identifier is then used to refer
            to the associated object.</p>
        </div>
        <div class="paragraph">
          <p>The scope of an object x extends textually from the point of its declaration
            to the end of the block (module, procedure, or record) to which the declaration
            belongs and hence to which the object is local. It excludes the scopes
            of equally named objects which are declared in nested blocks. The scope
            rules are:</p>
        </div>
        <div class="olist arabic">
          <ol class="arabic">
            <li>
              <p>No identifier may denote more than one object within a given scope
                (i.e. no identifier may be declared twice in a block);</p>
            </li>
            <li>
              <p>An object may only be referenced within its scope;</p>
            </li>
            <li>
              <p>The order of declaration is not significant;</p>
            </li>
            <li>
              <p>Identifiers denoting record fields (see <a href="#_record_types">Record types</a>)
                or type-bound procedures (see <a href="#_type_bound_procedures">Type-bound procedures</a>)
                are valid in record designators only.</p>
            </li>
          </ol>
        </div>
        <div class="paragraph">
          <p>An identifier declared in a module block may be followed by an export mark
            (<code>*</code> or <code>-</code>) in its declaration to indicate that
            it is exported. An identifier <code>x</code> exported by a module <code>M</code>            may be used in other modules, if they import <code>M</code> (see <a href="#_modules">Modules</a>).
            The identifier is then denoted as <code>M.x</code> in these modules and
            is called a qualified identifier. Identifiers marked with <code>-</code>            in their declaration are read-only in importing modules.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>qualident = [ident '.'] ident
identdef  = ident ['*' | '-']</pre>
          </div>
        </div>
        <div class="admonitionblock note">
          <table>
            <tr>
              <td class="icon">
                <div class="title">Note</div>
              </td>
              <td class="content">
                Oberon-07 only knows the <code>*</code> export mark; all module variables
                are exported read-only and exported record fields are writable. Oberon+
                and Oberon-2 permit finer control writability of exported variables
                and fields.
              </td>
            </tr>
          </table>
        </div>
        <div class="paragraph">
          <p>The following identifiers are predeclared; their meaning is defined in
            the indicated sections:</p>
        </div>
        <table class="tableblock frame-all grid-all spread">
          <colgroup>
            <col style="width: 25%;">
            <col style="width: 25%;">
            <col style="width: 25%;">
            <col style="width: 25%;">
          </colgroup>
          <tbody>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ABS</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ASH</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ASR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ASSERT</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BITAND</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BITNOT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BITOR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BITS</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BITXOR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BYTE</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CAP</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHAR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">COPY</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">DEC</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">DEFAULT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ENTIER</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">EXCL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">FLOOR</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">FLT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">HALT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">INC</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">INCL</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">INT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">INTEGER</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">LEN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">LONG</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">LONGINT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">LONGREAL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">LSL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">MAX</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">MIN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">NEW</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ODD</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ORD</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">PACK</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">REAL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">ROR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SHORT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SHORTINT</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SIZE</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">UNPK</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">VAL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">WCHR</p>
              </td>
              <td class="tableblock halign-left valign-top"></td>
              <td class="tableblock halign-left valign-top"></td>
            </tr>
          </tbody>
        </table>
        <div class="admonitionblock note">
          <table>
            <tr>
              <td class="icon">
                <div class="title">Note</div>
              </td>
              <td class="content">
                BYTE, ASR, FLOOR, ROR, LSL, FLT, PACK and UNPK are predeclared identifiers in Oberon-07
                and Oberon+, but not in Oberon-2. All lower-case versions are only
                predeclared in Oberon+.
              </td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_constant_declarations">5. Constant declarations</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>A constant declaration associates an identifier with a constant value.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>ConstDeclaration = identdef '=' ConstExpression
ConstExpression  = expression</pre>
          </div>
        </div>
        <div class="paragraph">
          <p>A constant expression is an expression that can be evaluated by a mere
            textual scan without actually executing the program. Its operands are
            constants (see <a href="#_operands">Operands</a>) or predeclared functions
            (see <a href="#_predeclared_function_procedures">Predeclared function procedures</a>)
            that can be evaluated at compile time. Examples of constant declarations
            are:</p>
        </div>
        <div class="literalblock">
          <div class="title">Examples:</div>
          <div class="content">
            <pre>N = 100
limit = 2*N - 1
fullSet = {min(set) .. max(set)}</pre>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_type_declarations">6. Type declarations</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>A data type determines the set of values which variables of that type may
            assume, and the operators that are applicable. A type declaration associates
            an identifier with a type. In the case of structured types (arrays and
            records) it also defines the structure of variables of this type. A structured
            type cannot contain itself.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>TypeDeclaration = identdef '=' type
type            = NamedType | ArrayType | RecordType
                  | PointerType | ProcedureType | enumeration
NamedType       = qualident</pre>
          </div>
        </div>
        <div class="literalblock">
          <div class="title">Examples:</div>
          <div class="content">
            <pre>Table = array N of real
Tree = pointer to Node
Node = record
  key: integer
  left, right: Tree
end
CenterTree = pointer to CenterNode
CenterNode = record (Node)
  width: integer
  subnode: Tree
end
Function = procedure(x: integer): integer</pre>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_basic_types">6.1. Basic types</h3>
          <div class="paragraph">
            <p>The basic types are denoted by predeclared identifiers. The associated
              operators are defined in <a href="#_operators">Operators</a> and the
              predeclared function procedures in <a href="#_predeclared_procedures">Predeclared procedures</a>.
              The values of the given basic types are the following:</p>
          </div>
          <table class="tableblock frame-all grid-all spread">
            <colgroup>
              <col style="width: 28.5714%;">
              <col style="width: 71.4286%;">
            </colgroup>
            <tbody>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">BOOLEAN, boolean</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the truth values true and false</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">BYTE, byte</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the integers between 0 and 255</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">CHAR, char</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the characters of the Latin-1 set (0x .. 0ffx)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">SHORTINT, shortint</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the integers between MIN(SHORTINT) and MAX(SHORTINT)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">INTEGER, INT, integer, int</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the integers between MIN(INTEGER) and MAX(INTEGER)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">LONGINT, longint</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the integers between MIN(LONGINT) and MAX(LONGINT)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">REAL, real</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the real numbers between MIN(REAL) and MAX(REAL)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">LONGREAL, longreal</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the real numbers between MIN(LONGREAL) and MAX(LONGREAL)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">SET, set</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the sets of integers between 0 and MAX(SET)</p>
                </td>
              </tr>
              <tr>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">WCHAR, wchar</p>
                </td>
                <td class="tableblock halign-left valign-top">
                  <p class="tableblock">the characters of the Unicode BMP set (0x .. 0d7ffx, 0f900x ..
                    0ffffx)</p>
                </td>
              </tr>
            </tbody>
          </table>
          <div class="paragraph">
            <p>Types LONGINT, INTEGER, SHORTINT and BYTE are integer types, types REAL
              and LONGREAL are floating point types, and together they are called
              numeric types. INT is the abbreviation for INTEGER. The specific bit
              precision of these types (besides BYTE) is implementation specific,
              but the larger type includes (the values of) the smaller type according
              to the following relations:</p>
          </div>
          <div id="type-inclusion-relations" class="literalblock">
            <div class="content">
              <pre>LONGINT &gt;= INTEGER &gt;= SHORTINT &gt;= BYTE
LONGREAL &gt;= REAL
REAL &gt;= SHORTINT
LONGREAL &gt;= LONGINT
WCHAR &gt;= CHAR</pre>
            </div>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  The precision of BYTE and CHAR is 8 bits. The precision of WCHAR is 16 bits. The
                  bit precision of LONGINT is limited by the bit precision of the
                  LONGREAL mantissa bit precision (which is 52 bits in case of IEEE
                  754 double precision representation). REAL is not expected to (fully)
                  include INTEGER; if an INTEGER is assigned to a REAL, the compiler
                  issues a warning unless the predeclared function FLT is used. The
                  bit precision of SHORTINT is equal or greater than the bit precision
                  of BYTE.
                </td>
              </tr>
            </table>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_array_types">6.2. Array types</h3>
          <div class="paragraph">
            <p>An array is a structure consisting of a number of elements which are
              all of the same type, called the element type. The number of elements
              of an array is called its length. The elements of the array are designated
              by indices, which are integers between 0 and the length minus 1.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ArrayType  = ARRAY [ LengthList ] OF type
	         | '[' [ LengthList ] ']' type
LengthList = length {',' length}
length     = ConstExpression</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>A type of the form</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>array L0, L1, ..., Ln of T</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>is understood as an abbreviation of</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>array L0 of
array L1 of
...
array Ln of T</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Arrays declared without length are called <em>open arrays</em>. They
              are restricted to pointer base types (see <a href="#_pointer_types">Pointer types</a>),
              element types of open array types, and formal parameter types (see
              <a href="#_formal_parameters">Formal parameters</a>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>array 10, N of integer
array of char
[N][M] T</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_record_types">6.3. Record types</h3>
          <div class="paragraph">
            <p>A record type is a structure consisting of a fixed number of elements,
              called fields, with possibly different types. The record type declaration
              specifies the name and type of each field. The scope of the field identifiers
              extends from the point of their declaration to the end of the record
              type, but they are also visible within designators referring to elements
              of record variables (see <a href="#_operands">Operands</a>). If a record
              type is exported, field identifiers that are to be visible outside
              the declaring module must be marked. They are called public fields;
              unmarked elements are called private fields.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>RecordType = RECORD ['(' BaseType ')']
             FieldList { [';'] FieldList} END
BaseType   = NamedType
FieldList  = [ IdentList ':' type ]
IdentList  = identdef { [','] identdef }</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Record types are extensible, i.e. a record type or a pointer to a record
              can be declared as an extension of another record type. In the example</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>T0 = record x: integer end
T1 = record (T0) y: real end</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>T1 is a (direct) <em>extension</em> of T0 and T0 is the (direct) base
              type of T1 (see <a href="#_definition_of_terms">Definition of terms</a>).
              An extended type T1 consists of the fields of its base type and of
              the fields which are declared in T1. In general all identifiers declared
              in the extended record must be different from the identifiers declared
              in its base type record(s). A pointer field of the base record can
              be re-declared in the extended record with a pointer type which is
              an extension of the corresponding base record field type <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup>.</p>
          </div>
          <div class="paragraph">
            <p>Alternatively, a pointer to record type can be specified as the base
              type. The record base type of the pointer is used as the base type
              of the declared record in this case.</p>
          </div>
          <div class="paragraph">
            <p>Each record is implicitly an extension of the predeclared type ANYREC.
              ANYREC does not contain any fields and can only be used in pointer
              and variable parameter declarations.</p>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>record
  day, month, year: integer
end

record
  name, firstname: array 32 of char
  age: integer
  salary: real
end</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_pointer_types">6.4. Pointer types</h3>
          <div class="paragraph">
            <p>Variables of a pointer type P assume as values pointers to variables
              of some type T. T is called the pointer base type of P and must be
              a record or array type. Pointer types adopt the extension relation
              of their pointer base types: if a type T1 is an extension of T, and
              P1 is of type <code>POINTER TO T1</code>, then P1 is also an extension
              of P.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>PointerType = ( POINTER TO | '^' ) type</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>If p is a variable of type <code>P = POINTER TO T</code>, a call of the
              predeclared procedure <code>NEW(p)</code> (see <a href="#_predeclared_procedures">Predeclared procedures</a>)
              allocates a variable of type T in free storage. If T is a record type
              or an array type with fixed length, the allocation has to be done with
              <code>NEW(p)</code>; if T is an n-dimensional open array type the allocation
              has to be done with <code>NEW(p, e<sub>0</sub>, &#8230;&#8203;, e<sub>n-1</sub>)</code>              where T is allocated with lengths given by the expressions e<sub>0</sub>,
              &#8230;&#8203;, e<sub>n-1</sub>. In either case a pointer to the allocated
              variable is assigned to <code>p</code>. <code>p</code> is of type P.
              The referenced variable <code>p^</code> is of type T. Any pointer variable
              may assume the value NIL, which points to no variable at all. All pointer
              fields or elements of a newly allocated record or array are set to
              NIL.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_procedure_types">6.5. Procedure types</h3>
          <div class="paragraph">
            <p>Variables of a procedure type T have a procedure (or NIL) as value. If
              a procedure P is assigned to a variable of type T, the formal parameter
              lists and result types (see <a href="#_formal_parameters">Formal parameters</a>)
              of P and T must <em>match</em> (see <a href="#_definition_of_terms">Definition of terms</a>).
              A procedure P assigned to a variable or a formal parameter must not
              be a predeclared or type-bound procedure.</p>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  Oberon 90, 2 and 07 don&#8217;t support assignment of procedures local to another
                  procedure to a procedure type variable. Oberon+ doesn&#8217;t make
                  this restriction.
                </td>
              </tr>
            </table>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ProcedureType = PROCEDURE [FormalParameters]</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_enumeration_types">6.6. Enumeration types</h3>
          <div class="paragraph">
            <p>An enumeration is a list of identifiers that denote the values which
              constitute a data type. These identifiers are used as constants in
              the program. They, and no other values, belong to this type. The values
              are ordered. and the ordering relation is defined by their sequence
              in the enumeration. The ordinal number of the first value is O.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>enumeration = '('  ident { [','] ident } ')'</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>(red, green, blue)
(club, diamond, heart, spade)
(Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday)</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>The ordinal number of an enumeration identifier can be obtained using
              the <code>ORD</code> predeclared function procedure. <code>VAL</code>              is the reverse operation. <code>MIN</code> returns the first and <code>MAX</code>              the last ident of the enumeration. <code>INC</code> returns the next
              and <code>DEC</code> the previous ident. If T is an enumeration type
              then <code>INC(MAX(T))</code> and <code>DEC(MIN(T))</code> are undefined
              and terminate the program.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_variable_declarations">7. Variable declarations</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Variable declarations introduce variables by defining an identifier and
            a data type for them.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>VariableDeclaration = IdentList ":" type</pre>
          </div>
        </div>
        <div class="paragraph">
          <p>Record and pointer variables have both a static type (the type with which
            they are declared - simply called their type) and a dynamic type (the
            type of their value at run time). For pointers and variable parameters
            of record type the dynamic type may be an extension of their static type.
            The static type determines which fields of a record are accessible. The
            dynamic type is used to call type-bound procedures (see <a href="#_type_bound_procedures">Type-bound procedures</a>).</p>
        </div>
        <div class="literalblock">
          <div class="title">Examples:</div>
          <div class="content">
            <pre>i, j, k: integer
x, y: real
p, q: bool
s: set
F: Function
a: array 100 of real
w: array 16 of record
     name: arra 32 of char
     count: integer
   end
t, c: Tree</pre>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_expressions">8. Expressions</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Expressions are constructs denoting rules of computation whereby constants
            and current values of variables are combined to compute other values
            by the application of operators and function procedures. Expressions
            consist of operands and operators. Parentheses may be used to express
            specific associations of operators and operands.</p>
        </div>
        <div class="sect2">
          <h3 id="_operands">8.1. Operands</h3>
          <div class="paragraph">
            <p>With the exception of set constructors and literal constants (numbers,
              character constants, or strings), operands are denoted by designators.
              A designator consists of an identifier referring to a constant, variable,
              or procedure. This identifier may possibly be qualified by a module
              identifier (see <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>              and <a href="#_modules">Modules</a>) and may be followed by selectors
              if the designated object is an element of a structure.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>designator = qualident {selector}
selector   = '.' ident | '[' ExpList ']' | '^' | '(' qualident ')'
ExpList    = expression {',' expression}</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>If <code>a</code> designates an array, then <code>a[e]</code> denotes
              that element of <code>a</code> whose index is the current value of
              the expression <code>e</code>. The type of <code>e</code> must be an
              <em>integer type</em>. A designator of the form <code>a[e<sub>0</sub>, e<sub>1</sub>, &#8230;&#8203;, e<sub>n</sub>]</code>              stands for <code>a[e<sub>0</sub>][e<sub>1</sub>]&#8230;&#8203;[e<sub>n</sub>]</code>.</p>
          </div>
          <div class="paragraph">
            <p>If <code>r</code> designates a record, then <code>r.f</code> denotes
              the field <code>f</code> of <code>r</code> or the procedure <code>f</code>              bound to the dynamic type of <code>r</code> (see <a href="#_type_bound_procedures">Type-bound procedures</a>).
              If <code>p</code> designates a pointer, <code>p^</code> denotes the
              variable which is referenced by <code>p</code>. The designators <code>p^.f</code>              and <code>p^[e]</code> may be abbreviated as <code>p.f</code> and <code>p[e]</code>,
              i.e. record and array selectors imply dereferencing.</p>
          </div>
          <div class="paragraph">
            <p>Dereferencing is also implied if a pointer is assigned to a variable
              of a record or array type, if a pointer is used as actual parameter
              for a formal parameter of a record or array type, or if a pointer is
              used as argument of the standard procedure LEN <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</sup>.</p>
          </div>
          <div class="paragraph">
            <p>If <code>a</code> or <code>r</code> are read-only, then also <code>a[e]</code>              and <code>r.f</code> are read-only.</p>
          </div>
          <div class="paragraph">
            <p>A type guard <code>v(T)</code> asserts that the dynamic type of <code>v</code>              is T (or an extension of T), i.e. program execution is aborted, if
              the dynamic type of <code>v</code> is not T (or an extension of T).
              Within the designator, <code>v</code> is then regarded as having the
              static type T. The guard is applicable, if</p>
          </div>
          <div class="olist arabic">
            <ol class="arabic">
              <li>
                <p><code>v</code> is a variable parameter of record type or <code>v</code>                  is a pointer, and if</p>
              </li>
              <li>
                <p>T is an extension of the static type of <code>v</code>.</p>
              </li>
            </ol>
          </div>
          <div class="paragraph">
            <p>If the designated object is a constant or a variable, then the designator
              refers to its current value. If it is a procedure, the designator refers
              to that procedure unless it is followed by a (possibly empty) parameter
              list in which case it implies an activation of that procedure and stands
              for the value resulting from its execution. The actual parameters must
              correspond to the formal parameters as in proper procedure calls (see
              <a href="#_formal_parameters">Formal parameters</a>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>i                        // integer
a[i]                     // real
w[3].name[i]             // char
t.left.right             // Tree
t(CenterTree).subnode    // Tree</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_operators">8.2. Operators</h3>
          <div class="paragraph">
            <p>Four classes of operators with different precedences (binding strengths)
              are syntactically distinguished in expressions. The operator <code>~</code>              has the highest precedence, followed by multiplication operators, addition
              operators, and relations. Operators of the same precedence associate
              from left to right. For example, <code>x-y-z</code> stands for <code>(x-y)-z</code>.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>expression       = SimpleExpression [ relation SimpleExpression ]
relation         = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN | IS
SimpleExpression = ['+' | '-'] term { AddOperator term }
AddOperator      = '+' | '-' | OR
term             = factor {MulOperator factor}
MulOperator      = '*' | '/' | DIV | MOD | '&amp;'
literal          = number | string | hexstring | hexchar
                   | NIL | TRUE | FALSE | set
factor           = literal | designator [ActualParameters]
	               | '(' expression ')' | '~' factor
ActualParameters = '(' [ ExpList ] ')'
set              = '{' [ element {',' element} ] '}'
element          = expression ['..' expression]</pre>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_logical_operators">8.2.1. Logical operators</h4>
            <table class="tableblock frame-all grid-all spread">
              <colgroup>
                <col style="width: 16.6666%;">
                <col style="width: 33.3333%;">
                <col style="width: 16.6666%;">
                <col style="width: 33.3335%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">OR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">logical disjunction</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>p or q</code></p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><em>if p then TRUE, else q</em></p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">&amp;</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">logical conjunction</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>p &amp; q</code></p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><em>if p then q, else FALSE</em></p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">~</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">negation</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><code>~p</code></p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock"><em>not p</em></p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>These operators apply to BOOLEAN operands and yield a BOOLEAN result.</p>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_arithmetic_operators">8.2.2. Arithmetic operators</h4>
            <table class="tableblock frame-all grid-all" style="width: 50%;">
              <colgroup>
                <col style="width: 25%;">
                <col style="width: 75%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">+</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">sum</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">-</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">difference</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">*</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">product</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">/</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">real quotient</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">DIV</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer quotient</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">MOD</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">modulus</p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>The operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>                apply to operands of numeric types. The type of the result is the
                type of that operand which includes the type of the other operand,
                except for division (<code>/</code>), where the result is the smallest
                real type which includes both operand types. When used as monadic
                operators, <code>-</code> denotes sign inversion and <code>+</code>                denotes the identity operation. The operators <code>DIV</code> and
                <code>MOD</code> apply to integer operands only. They are related
                by the following formulas defined for any <code>x</code> and positive
                divisors <code>y</code>:</p>
            </div>
            <div class="literalblock">
              <div class="content">
                <pre>x = (x DIV y) * y + (x MOD y)
0 &lt;= (x MOD y) &lt; y</pre>
              </div>
            </div>
            <div class="literalblock">
              <div class="title">Examples:</div>
              <div class="content">
                <pre>x    y    x DIV y    x MOD y
5    3    1          2
-5   3    -2         1</pre>
              </div>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_set_operators">8.2.3. Set Operators</h4>
            <table class="tableblock frame-all grid-all" style="width: 70%;">
              <colgroup>
                <col style="width: 25%;">
                <col style="width: 75%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">+</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">union</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">-</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">difference (x - y = x * (-y))</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">*</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">intersection</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">/</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">symmetric set difference (x / y = (x-y) + (y-x))</p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>Set operators apply to operands of type SET and yield a result of type
                SET. The monadic minus sign denotes the complement of <code>x</code>,
                i.e. <code>-x</code> denotes the set of integers between 0 and <code>MAX(SET)</code>                which are not elements of <code>x</code>. Set operators are not associative
                (<code>(a+b)-c # a+(b-c)</code>).</p>
            </div>
            <div class="paragraph">
              <p>A set constructor defines the value of a set by listing its elements
                between curly brackets. The elements must be integers in the range
                <code>0..MAX(SET)</code>. A range <code>a..b</code> denotes all integers
                in the interval [a, b].</p>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_relations">8.2.4. Relations</h4>
            <table class="tableblock frame-all grid-all" style="width: 50%;">
              <colgroup>
                <col style="width: 25%;">
                <col style="width: 75%;">
              </colgroup>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">=</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">equal</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">#</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">unequal</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">&lt;</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">less</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">&lt;=</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">less or equal</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">&gt;</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">greater</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">&gt;=</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">greater or equal</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">IN</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">set membership</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">IS</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">type test</p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>Relations yield a BOOLEAN result. The relations <code>=</code>, <code>#</code>,
                <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>                apply to the numeric types, as well as enumerations, CHAR, strings,
                and CHAR arrays containing <code>0x</code> as a terminator. The relations
                <code>=</code> and <code>#</code> also apply to BOOLEAN and SET,
                as well as to pointer and procedure types (including the value NIL).
                <code>x IN s</code> stands for <em>x is an element of s</em>. <code>x</code>                must be of an integer type, and <code>s</code> of type SET. <code>v IS T</code>                stands for <em>the dynamic type of <code>v</code> is T (or an extension of T )</em>                and is called a type test. It is applicable if</p>
            </div>
            <div class="olist arabic">
              <ol class="arabic">
                <li>
                  <p><code>v</code> is a variable parameter of record type or <code>v</code>                    is a pointer, and if</p>
                </li>
                <li>
                  <p>T is an extension of the static type of <code>v</code>.</p>
                </li>
              </ol>
            </div>
            <div class="literalblock">
              <div class="title">Examples:</div>
              <div class="content">
                <pre>1991                   // integer
i div 3                // integer
~p or q                // boolean
(i+j) * (i-j)          // integer
s - {8, 9, 13}         // set
i + x                  // real
a[i+j] * a[i-j]        // real
(0&lt;=i) &amp; (i&lt;100)       // boolean
t.key = 0              // boolean
k in {i..j-1}          // boolean
w[i].name &lt;= "John"    // boolean
t is CenterTree        // boolean</pre>
              </div>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_function_call">8.2.5. Function Call</h4>
            <div class="paragraph">
              <p>A function call is a factor in an expression. In contrast to <a href="#_procedure_calls">Procedure calls</a>                in a function call the actual parameter list is mandatory. Each expression
                in the actual parameters list (if any) is used to initialize a corresponding
                formal parameter. The number of expressions in the actual parameter
                list must correspond the number of formal parameters. See also
                <a
                  href="#_formal_parameters">Formal parameters</a>.</p>
            </div>
            <div class="literalblock">
              <div class="title">Syntax:</div>
              <div class="content">
                <pre>FunctionCall           = designator ActualParameters
ActualParameters = '(' [ ExpList ] ')'</pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_statements">9. Statements</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Statements denote actions. There are elementary and structured statements.
            Elementary statements are not composed of any parts that are themselves
            statements. They are the assignment, the procedure call, the return,
            and the <code>exit</code> statement. Structured statements are composed
            of parts that are themselves statements. They are used to express sequencing
            and conditional, selective, and repetitive execution.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>statement = [ assignment | ProcedureCall | IfStatement
            | CaseStatement  | WithStatement | LoopStatement
            | ExitStatement | ReturnStatement
	        | RepeatStatement | ForStatement ]</pre>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_statement_sequences">9.1. Statement sequences</h3>
          <div class="paragraph">
            <p>Statement sequences denote the sequence of actions specified by the component
              statements which are optionally separated by semicolons.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>StatementSequence = statement { [";"] statement}</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_assignments">9.2. Assignments</h3>
          <div class="paragraph">
            <p>Assignments replace the current value of a variable by a new value specified
              by an expression. The expression must be <em>assignment compatible</em>              with the variable (see <a href="#_definition_of_terms">Definition of terms</a>).
              The assignment operator is written as <code>:=</code> and pronounced
              as <em>becomes</em>.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>assignment = designator ':=' expression</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>If an expression <code>e</code> of type T<sub>e</sub> is assigned to
              a variable <code>v</code> of type T<sub>v</sub>, the following happens:</p>
          </div>
          <div class="olist arabic">
            <ol class="arabic">
              <li>
                <p>if T<sub>v</sub> and T<sub>e</sub> are record types, only those fields
                  of T<sub>e</sub> are assigned which also belong to T<sub>v</sub>                  (projection); the dynamic type of <code>v</code> must be the same
                  as the static type of <code>v</code> and is not changed by the
                  assignment;</p>
              </li>
              <li>
                <p>if T<sub>v</sub> and T<sub>e</sub> are pointer types, the dynamic
                  type of <code>v</code> becomes the dynamic type of <code>e</code>;</p>
              </li>
              <li>
                <p>if T<sub>v</sub> is <code>ARRAY n OF CHAR</code> and <code>e</code>                  is a string of length m &lt; n, <code>v[i]</code> becomes e<sub>i</sub>                  for i = 0..m-1 and <code>v[m]</code> becomes 0X;</p>
              </li>
              <li>
                <p>if T<sub>v</sub> and T<sub>e</sub> are open or closed CHAR arrays,
                  <code>v[i]</code> becomes <code>e[i]</code> for i = 0..STRLEN(e);
                  if LEN(v) &lt;= STRLEN(e) or <code>e</code> is not terminated by
                  0X the program halts;</p>
              </li>
              <li>
                <p>if T<sub>v</sub> is an open CHAR array and <code>e</code> is a string
                  <code>v[i]</code> becomes <code>e[i]</code> for i = 0..LEN(e)-1
                  and <code>v[LEN(e)]</code> becomes 0X; if LEN(v) &lt;= LEN(e) the
                  program halts;</p>
              </li>
            </ol>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>i := 0
p := i = j
x := i + 1
k := log2(i+j)
F := log2
s := {2, 3, 5, 7, 11, 13}
a[i] := (x+y) * (x-y)
t.key := i
w[i+1].name := "John"
t := c</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_procedure_calls">9.3. Procedure calls</h3>
          <div class="paragraph">
            <p>A procedure call activates a procedure. It may contain a list of actual
              parameters which replace the corresponding formal parameter list defined
              in the procedure declaration (see <a href="#_procedure_declarations">Procedure declarations</a>).
              The correspondence is established by the positions of the parameters
              in the actual and formal parameter lists. There are three kinds of
              parameters: <em>variable</em> (VAR), IN and <em>value</em> parameters.</p>
          </div>
          <div class="paragraph">
            <p>If a formal parameter is a VAR or IN parameter, the corresponding actual
              parameter must be a designator denoting a variable. If it denotes an
              element of a structured variable, the component selectors are evaluated
              when the formal/actual parameter substitution takes place, i.e. before
              the execution of the procedure. If a formal parameter is a value parameter,
              the corresponding actual parameter must be an expression. This expression
              is evaluated before the procedure activation, and the resulting value
              is assigned to the formal parameter (see also <a href="#_formal_parameters">Formal parameters</a>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ProcedureCall = designator [ ActualParameters ]</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>WriteInt(i*2+1)
inc(w[k].count)
t.Insert("John")</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_if_statements">9.4. If statements</h3>
          <div class="paragraph">
            <p>If statements specify the conditional execution of guarded statement
              sequences. The boolean expression preceding a statement sequence is
              called its guard. The guards are evaluated in sequence of occurrence,
              until one evaluates to TRUE, whereafter its associated statement sequence
              is executed. If no guard is satisfied, the statement sequence following
              the symbol ELSE is executed, if there is one.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>IfStatement    = IF expression THEN StatementSequence
	             {ElsifStatement} [ElseStatement] END
ElsifStatement = ELSIF expression THEN StatementSequence
ElseStatement  = ELSE StatementSequence</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Example:</div>
            <div class="content">
              <pre>if (ch &gt;= "A") &amp; (ch &lt;= "Z") then ReadIdentifier
elsif (ch &gt;= "0") &amp; (ch &lt;= "9") then ReadNumber
elsif (ch = "'") OR (ch = '"') then ReadString
else SpecialCharacter
end</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_case_statements">9.5. Case statements</h3>
          <div class="paragraph">
            <p>Case statements specify the selection and execution of a statement sequence
              according to the value of an expression. First the case expression
              is evaluated, then that statement sequence is executed whose case label
              list contains the obtained value. The case expression must either be
              of an integer type that includes the types of all case labels, or both
              the case expression and the case labels must be of type CHAR. Case
              labels are constants, and no value must occur more than once. If the
              value of the expression does not occur as a label of any case, the
              statement sequence following the symbol ELSE is selected, if there
              is one, otherwise the program is aborted.</p>
          </div>
          <div class="paragraph">
            <p>The type T of the case expression (case variable) may also be a record
              or pointer type. Then the case labels must be extensions of T, and
              in the statements S<sub>i</sub> labelled by T<sub>i</sub>, the case
              variable is considered as of type T<sub>i</sub>.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>CaseStatement = CASE expression OF Case { '|' Case }
	            [ ELSE StatementSequence ] END
Case          = [ CaseLabelList ':' StatementSequence ]
CaseLabelList = LabelRange { ',' LabelRange }
LabelRange    = label [ '..' label ]
label         = ConstExpression</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>case ch of
  "A" .. "Z": ReadIdentifier
| "0" .. "9": ReadNumber
| "'", '"': ReadString
else SpecialCharacter
end

type R  = record a: integer end
	 R0 = record (R) b: integer end
	 R1 = record (R) b: real end
	 R2 = record (R) b: set end
	 P  = ^R
	 P0 = ^R0
	 P1 = ^R1
	 P2 = ^R2
var p: P
case p of
	P0: p.b := 10 |
	P1: p.b := 2.5 |
	P2: p.b := {0, 2}
end</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_while_statements">9.6. While statements</h3>
          <div class="paragraph">
            <p>While statements specify the repeated execution of a statement sequence
              while the Boolean expression (its guard) yields TRUE. The guard is
              checked before every execution of the statement sequence. The ELSIF
              part is integrated in the loop; as long as any of the Boolean expressions
              (either the WHILE or ELSIF guard) yields TRUE, the corresponding statement
              sequence is executed; repetition only terminates, when all guards are
              FALSE.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>WhileStatement = WHILE expression DO StatementSequence
	             {ELSIF expression DO StatementSequence} END</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>while i &gt; 0 do i := i div 2; k := k + 1 end

while (t # nil) &amp; (t.key # i) do t := t.left end

// Euclidean algorithm to compute the greatest common divisor of m and n:
while m &gt; n do
	m := m – n
elsif n &gt; m do
	n := n – m
end
// is equivalent to:
loop
	if m &gt; 0 then
		m := m – n
	elsif n &gt; m then
		n := n – m
	else
		exit
	end
end</pre>
            </div>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  The ELSIF part was added to Oberon-07. It is noteably Dijkstra’s form of the WHILE
                  loop. Contrary to intuition, the ELSIF part is not executed only
                  if the first check of the WHILE guard evaluates to FALSE; instead,
                  both parts are checked and executed until both guards evaluate
                  to FALSE.
                </td>
              </tr>
            </table>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_repeat_statements">9.7. Repeat statements</h3>
          <div class="paragraph">
            <p>A repeat statement specifies the repeated execution of a statement sequence
              until a condition specified by a Boolean expression is satisfied. The
              statement sequence is executed at least once.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>RepeatStatement = REPEAT StatementSequence UNTIL expression</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_for_statements">9.8. For statements</h3>
          <div class="paragraph">
            <p>A for statement specifies the repeated execution of a statement sequence
              while a progression of values is assigned to a control variable of
              the for statement. Control variables can be of integer or enumeration
              types. An explicit BY expression is only supported for integer control
              variables.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ForStatement = FOR ident ':=' expression TO expression
			   [BY ConstExpression]
	           DO StatementSequence END</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>The statement</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>for v := first to last by step do statements end</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>is equivalent to</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>temp := last; v := first
if step &gt; 0 then
    while v &lt;= temp do statements; INC(v,step) end
else
    while v &gt;= temp do statements; DEC(v,-step) end
end</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>temp has the same type as <code>v</code>. For integer control variables,
              step must be a nonzero constant expression; if step is not specified,
              it is assumed to be 1. For enumeration control variables, there is
              no explicit step, but the INC or DEC version of the while loop is used
              depending on ORD(first) &#8656; ORD(last).</p>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>for i := 0 to 79 do k := k + a[i] end
for i := 79 to 1 by -1 do a[i] := a[i-1] end</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_loop_statements">9.9. Loop statements</h3>
          <div class="paragraph">
            <p>A loop statement specifies the repeated execution of a statement sequence.
              It is terminated upon execution of an exit statement within that sequence
              (see <a href="#_return_and_exit_statements">Return and exit statements</a>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>LoopStatement = LOOP StatementSequence END
ExitStatement = EXIT</pre>
            </div>
          </div>
          <div class="literalblock">
            <div class="title">Example:</div>
            <div class="content">
              <pre>loop
  ReadInt(i)
  if i &lt; 0 then exit end
  WriteInt(i)
end</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Loop statements are useful to express repetitions with several exit points
              or cases where the exit condition is in the middle of the repeated
              statement sequence.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_return_and_exit_statements">9.10. Return and exit statements</h3>
          <div class="paragraph">
            <p>A return statement indicates the termination of a procedure. It is denoted
              by the symbol RETURN, followed by an expression if the procedure is
              a function procedure. The type of the expression must be assignment
              compatible (see <a href="#_definition_of_terms">Definition of terms</a>)
              with the result type specified in the procedure heading (see <a href="#_procedure_declarations">Procedure declarations</a>).</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ReturnStatement = RETURN [ expression ]
ExitStatement   = EXIT</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Function procedures require the presence of a return statement indicating
              the result value. In proper procedures, a return statement is implied
              by the end of the procedure body. Any explicit return statement therefore
              appears as an additional (probably exceptional) termination point.</p>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  The optional expression causes an LL(k) ambiguity which can be resolved in that the
                  parser expects an return expression if the procedure has a return
                  type and vice versa.
                </td>
              </tr>
            </table>
          </div>
          <div class="paragraph">
            <p>An exit statement is denoted by the symbol EXIT. It specifies termination
              of the enclosing loop statement and continuation with the statement
              following that loop statement. Exit statements are contextually, although
              not syntactically associated with the loop statement which contains
              them.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_with_statements">9.11. With statements</h3>
          <div class="paragraph">
            <p>With statements execute a statement sequence depending on the result
              of a type test and apply a type guard to every occurrence of the tested
              variable within this statement sequence.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>WithStatement = WITH Guard DO StatementSequence
	            { '|' Guard DO StatementSequence}
	            [ ELSE StatementSequence ] END
Guard         = qualident ':' qualident</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>If <code>v</code> is a variable parameter of record type or a pointer
              variable, and if it is of a static type T0, the statement</p>
          </div>
          <div class="literalblock">
            <div class="content">
              <pre>with v: T1 do S1 | v: T2 do S2 else S3 end</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>has the following meaning: if the dynamic type of <code>v</code> is T1,
              then the statement sequence S1 is executed where <code>v</code> is
              regarded as if it had the static type T1; else if the dynamic type
              of <code>v</code> is T2, then S2 is executed where <code>v</code> is
              regarded as if it had the static type T2; else S3 is executed. T1 and
              T2 must be extensions of T0. If no type test is satisfied and if an
              else clause is missing the program is aborted.</p>
          </div>
          <div class="literalblock">
            <div class="title">Example:</div>
            <div class="content">
              <pre>with t: CenterTree do i := t.width; c := t.subnode end</pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_procedure_declarations">10. Procedure declarations</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>A procedure declaration consists of a procedure heading and a procedure
            body. The heading specifies the procedure identifier and the formal parameters
            (see <a href="#Formal Parameters">[Formal Parameters]</a>). For type-bound
            procedures it also specifies the receiver parameter. The body contains
            declarations and statements. The procedure identifier must be repeated
            at the end of the procedure declaration unless it has no body.</p>
        </div>
        <div class="paragraph">
          <p>There are two kinds of procedures: proper procedures and function procedures.
            The latter are activated by a function designator as a constituent of
            an expression and yield a result that is an operand of the expression.
            Proper procedures are activated by a procedure call. A procedure is a
            function procedure if its formal parameters specify a result type. Each
            control path of a function procedure must return a value.</p>
        </div>
        <div class="paragraph">
          <p>All constants, variables, types, and procedures declared within a procedure
            body are local to the procedure. Since procedures may be declared as
            local objects too, procedure declarations may be nested. The call of
            a procedure within its declaration implies recursive activation.</p>
        </div>
        <div class="paragraph">
          <p>In case of nested procedure declarations, inner procedures have access
            to constants, types and procedures declared in the environment of the
            procedure (unless shadowed by a local declaration), but don&#8217;t have
            access to the parameters or local variables of outer procedures.</p>
        </div>
        <div class="paragraph">
          <p>A procedure body may have no statements in which case the ident after the
            END keyword can also be left out; in a function procedure with no statements
            a return statement with a default value is assumed.</p>
        </div>
        <div class="admonitionblock note">
          <table>
            <tr>
              <td class="icon">
                <div class="title">Note</div>
              </td>
              <td class="content">
                In Oberon 90 and Oberon-2 (in contrast to Oberon-07) the parameters and local variables
                of an outer procedure can be accessed from an inner procedure, but
                this features is a cause for considerably higher complexity of the
                compiler, with questionable added value, and can easily be worked
                around in practice.
              </td>
            </tr>
          </table>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>ProcedureDeclaration = ProcedureHeading [';']
                       ProcedureBody END [ ident ]
ProcedureHeading     = ( PROCEDURE | PROC )
					   [Receiver] identdef [ FormalParameters ]
ProcedureBody        = DeclarationSequence
                       [ BEGIN StatementSequence
                       | ReturnStatement [';'] ]
Receiver             = '(' [VAR] ident ':' ident ')'
DeclarationSequence  = { CONST { ConstDeclaration [';'] }
					   | TYPE { TypeDeclaration [';'] }
					   | VAR { VariableDeclaration [';'] }
					   | ProcedureDeclaration [';'] }</pre>
          </div>
        </div>
        <div class="paragraph">
          <p>If a procedure declaration specifies a receiver parameter, the procedure
            is considered to be bound to a type (see <a href="#_type_bound_procedures">Type-bound procedures</a>).</p>
        </div>
        <div class="sect2">
          <h3 id="_formal_parameters">10.1. Formal parameters</h3>
          <div class="paragraph">
            <p>Formal parameters are identifiers declared in the formal parameter list
              of a procedure. They correspond to actual parameters specified in the
              procedure call. The correspondence between formal and actual parameters
              is established when the procedure is called. There are three kinds
              of parameters, value, variable (VAR) and IN parameters, indicated in
              the formal parameter list by the absence or presence of the keyword
              VAR and IN.</p>
          </div>
          <div class="paragraph">
            <p>Value parameters are local variables to which the value of the corresponding
              actual parameter is assigned as an initial value. VAR parameters correspond
              to actual parameters that are variables, and they stand for these variables.
              IN parameters are like VAR parameters, but they are read-only in the
              procedure body.</p>
          </div>
          <div class="paragraph">
            <p>The scope of a formal parameter extends from its declaration to the end
              of the procedure block in which it is declared. A function procedure
              without parameters must have an empty parameter list. It must be called
              by a function designator whose actual parameter list is empty too.</p>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  In contrast to previous Oberon versions the result type of a procedure may also be
                  a structured type.
                </td>
              </tr>
            </table>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>FormalParameters = '(' [ FPSection { [';'] FPSection } ] ')'
                   [ ':' ReturnType ]
ReturnType       = NamedType | ( POINTER TO | '^') NamedType
FPSection        = [ VAR | IN ] ident { [','] ident }
                   ':' FormalType
FormalType       = type</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Let T<sub>f</sub> be the type of a formal parameter <code>f</code> and
              T<sub>a</sub> the type of the corresponding actual parameter <code>a</code>.
              If T<sub>f</sub> is an open array, then T<sub>a</sub> must be <em>array compatible</em>              to <code>f</code>; the lengths of <code>f</code> are taken from <code>a</code>.
              Otherwise T<sub>a</sub> must be <em>parameter compatible</em> to <code>f</code>              (see <a href="#_definition_of_terms">Definition of terms</a>).</p>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  Also value parameters can have an open array type, but for efficiency reasons (to
                  avoid unneccessary copying) open arrays should be VAR or IN parameters.
                </td>
              </tr>
            </table>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>proc ReadInt(var x: integer)
  var i: integer; ch: char
begin i := 0; Read(ch)
  while ("0" &lt;= ch) &amp; (ch &lt;= "9") do
    i := 10*i + (ord(ch)-ord("0")); Read(ch)
  end
  x := i
end ReadInt

proc WriteInt(x: integer) // 0 &lt;= x &lt;100000
var i: integer; buf: [5]integer
begin i := 0
  repeat buf[i] := x mod 10; x := x div 10; inc(i) until x = 0
  repeat dec(i); Write(chr(buf[i] + ord("0"))) until i = 0
end WriteInt

proc WriteString(s: []char)
  var i: integer
begin i := 0
  while (i &lt; len(s)) &amp; (s[i] # 0x) do Write(s[i]); inc(i) end
end WriteString

proc log2(x: integer): integer
  var y: integer // assume x&gt;0
begin
  y := 0; while x &gt; 1 do x := x div 2; inc(y) end
  return y
end log2</pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_type_bound_procedures">10.2. Type-bound procedures</h3>
          <div class="paragraph">
            <p>Procedures may be associated with a record type declared in the same
              scope. The procedures are said to be bound to the record type. The
              binding is expressed by the type of the receiver in the heading of
              a procedure declaration. The receiver may be either a variable (VAR)
              parameter of record type T or a value parameter of type POINTER TO
              T (where T is a record type). The procedure is bound to the type T
              and is considered local to it.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>ProcedureHeading = ( PROCEDURE | PROC )
				   [Receiver] identdef [ FormalParameters ]
Receiver         = '(' [VAR] ident ':' ident ')'</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>If a procedure P is bound to a type T0, it is implicitly also bound to
              any type T1 which is an extension of T0. However, a procedure P' (with
              the same name as P) may be explicitly bound to T1 in which case it
              overrides the binding of P. P' is considered a redefinition of P for
              T1. The formal parameter lists of P and P' must <em>match</em> (see
              <a href="#_definition_of_terms">Definition of terms</a>). Also the
              result types must <em>match</em>, or if P and P' both have pointer
              result types, then the result type of P' must be an <em>extension</em>              of the result type of P <sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote.">5</a>]</sup>.
              If P and T1 are exported (see <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>)
              P' must be exported too.</p>
          </div>
          <div class="paragraph">
            <p>If <code>v</code> is a designator and <code>P</code> is a type-bound
              procedure, then <code>v.P</code> denotes that procedure <code>P</code>              which is bound to the dynamic type of <code>v</code>. Note, that this
              may be a different procedure than the one bound to the static type
              of <code>v</code>. <code>v</code> is passed to `P&#8217;s receiver
              according to the parameter passing rules specified in Chapter <a href="#_formal_parameters">Formal parameters</a>.</p>
          </div>
          <div class="paragraph">
            <p>If <code>r</code> is the receiver parameter of P declared with type T,
              <code>r.P^</code> denotes the (redefined, sometimes calles <em>super</em>)
              procedure P bound to a base type of T.</p>
          </div>
          <div class="literalblock">
            <div class="title">Examples:</div>
            <div class="content">
              <pre>proc (t: Tree) Insert (node: Tree)
  var p, father: Tree
begin p := t
  repeat father := p
    if node.key = p.key then return end
    if node.key &lt; p.key then
      p := p.left
    else
      p := p.right
    end
  until p = nil
  if node.key &lt; father.key then
    father.left := node
  else
    father.right := node
  end
  node.left := nil; node.right := nil
end Insert

proc (t: CenterTree) Insert (node: Tree) // redefinition
begin
  WriteInt(node(CenterTree).width)
  t.Insert^(node)  // calls the Insert procedure bound to Tree
end Insert</pre>
            </div>
          </div>
          <div class="admonitionblock note">
            <table>
              <tr>
                <td class="icon">
                  <div class="title">Note</div>
                </td>
                <td class="content">
                  The name of a type-bound procedure must be unique within the type to which it is
                  bound, not within the scope in which it is declared.
                </td>
              </tr>
            </table>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_predeclared_procedures">10.3. Predeclared procedures</h3>
          <div class="paragraph">
            <p>The following table lists the predeclared procedures. Some are generic
              procedures, i.e. they apply to several types of operands. <code>v</code>              stands for a variable, <code>x</code> and <code>n</code> for expressions,
              and T for a type.</p>
          </div>
          <div class="sect3">
            <h4 id="_predeclared_function_procedures">10.3.1. Predeclared function procedures</h4>
            <table class="tableblock frame-all grid-all spread">
              <colgroup>
                <col style="width: 12.5%;">
                <col style="width: 25%;">
                <col style="width: 25%;">
                <col style="width: 37.5%;">
              </colgroup>
              <thead>
                <tr>
                  <th class="tableblock halign-left valign-top">Name</th>
                  <th class="tableblock halign-left valign-top">Argument type</th>
                  <th class="tableblock halign-left valign-top">Result type</th>
                  <th class="tableblock halign-left valign-top">Function</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ABS(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">numeric type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">type of x</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">absolute value</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ASH(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, n: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">arithmetic shift (x * 2<sup>n</sup>)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ASR(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, n: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">signed shift right, x DIV 2<sup>n</sup></p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CAP(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x is letter: corresponding capital letter</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BITAND(x,y)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, y: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">bitwise AND</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BITNOT(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">bitwise NOT</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BITOR(x,y)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, y: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">bitwise OR</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BITS(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">SET</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">set corresponding to the integer; the first element corresponds
                      to the least significant digit of the integer and the last
                      element to the most significant digit.</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BITXOR(x,y)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, y: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">bitwise XOR</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CHR(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Latin-1 character with ordinal number x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">DEFAULT(T)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = basic type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">zero for numeric and character types, false for boolean, empty
                      set</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">same as MIN(T)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = pointer/proc type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">nil</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = record/array type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">all fields/elements set to their DEFAULT type</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ENTIER(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">real type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LONGINT</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">largest integer not greater than x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">FLOOR(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">FLT(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">REAL</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">identity</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LEN(v, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: array n: integer</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">length of v in dimension n (first dimension = 0)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LEN(v)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: array</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">equivalent to LEN(v, 0)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">length of string (including the terminating 0X)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LONG(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: SHORTINT</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">identity</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LONGINT</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: REAL</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LONGREAL</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: CHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">projection</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: array of char or Latin-1 string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Unicode string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">projection</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">LSL(x,n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, n: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">logical shift left, x * 2<sup>n</sup></p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">MAX(T)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = basic type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">maximum value of type T</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = SET</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">maximum element of a set</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">last element of the enumeration</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">MAX(x,y)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x,y: numeric type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">numeric type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">greater of x and y, returns smallest numeric type including both
                      arguments</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x,y: character type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">character type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">greater of x and y, returns smallest character type including
                      both arguments</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">MIN(T)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = basic type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">minimum value of type T</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = SET</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">0</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T = enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">first element of the enumeration</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">MIN(x,y)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x,y: numeric type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">numeric type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">smaller of x and y, returns smallest numeric type including both
                      arguments</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x,y: character type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">character type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">smaller of x and y, returns smallest character type including
                      both arguments</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ODD(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BOOLEAN</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x MOD 2 = 1</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ORD(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: CHAR or WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BYTE or SHORT</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ordinal number of x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ordinal number of the given identifier</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: BOOLEAN</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BYTE</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">TRUE = 1, FALSE = 0</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: set type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">number representing the set; the first element corresponds to
                      the least significant digit of the number and the last element
                      to the most significant digit.</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ROR(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x, n: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x rotated right by n bits</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">SHORT(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: LONGINT</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">identity</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">SHORTINT</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">identity</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: LONGREAL</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">REAL</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">identity (truncation possible)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">CHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">projection (0x if there is no projection)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: array of wchar or Unicode string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Latin-1 string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">projection ("?" for characters where there is no projection)</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">BYTESIZE(T)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">any type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">number of bytes required by T</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">STRLEN(s)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">s: array of char</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">dynamic length of the string up to and not including the terminating
                      0X</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">s: string</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">VAL(T,x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">T:enumeration type x:ordinal number</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">the value with the ordinal number x.</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">WCHR(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">WCHAR</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">Unicode BMP character with ordinal number x</p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="admonitionblock note">
              <table>
                <tr>
                  <td class="icon">
                    <div class="title">Note</div>
                  </td>
                  <td class="content">
                    The functions ENTIER(x) or FLOOR(x) round down to the largest integer not greater
                    than x. The functions are identical, but the former is defined
                    in Oberon-2 and the latter in Oberon-07.
                  </td>
                </tr>
              </table>
            </div>
            <div class="literalblock">
              <div class="title">Exampes:</div>
              <div class="content">
                <pre>FLOOR(1.5) = 1; FLOOR(-1.5) = -2</pre>
              </div>
            </div>
            <div class="admonitionblock note">
              <table>
                <tr>
                  <td class="icon">
                    <div class="title">Note</div>
                  </td>
                  <td class="content">
                    The function BYTESIZE(T) is called SIZE(T) in Oberon-2.
                  </td>
                </tr>
              </table>
            </div>
          </div>
          <div class="sect3">
            <h4 id="_predeclared_proper_procedures">10.3.2. Predeclared proper procedures</h4>
            <table class="tableblock frame-all grid-all spread">
              <colgroup>
                <col style="width: 16.6666%;">
                <col style="width: 33.3333%;">
                <col style="width: 50.0001%;">
              </colgroup>
              <thead>
                <tr>
                  <th class="tableblock halign-left valign-top">Name</th>
                  <th class="tableblock halign-left valign-top">Argument types</th>
                  <th class="tableblock halign-left valign-top">Function</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ASSERT(x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: Boolean expression</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">terminate program execution if not x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">ASSERT(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: Boolean expression</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">terminate program execution if not x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">n: integer constant</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">COPY(x, v)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x: CHAR array, string</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: CHAR array</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">DEC(v)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v - 1</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">previous ident in enumeration</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">DEC(v, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v, n: integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v - n</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">EXCL(v, x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: SET; x: integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v - {x}</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">HALT(n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer constant</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">terminate program execution</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INC(v)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v + 1</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">enumeration type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">next ident in enumeration</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INC(v, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v, n: integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v + n</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">INCL(v, x)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: SET; x: integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v := v + {x}</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">NEW(v)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">pointer to record or</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">allocate v^</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">fixed array</p>
                  </td>
                  <td class="tableblock halign-left valign-top"></td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">NEW(v,x<sub>0</sub>,&#8230;&#8203;,x<sub>n</sub>)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">v: pointer to open array</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">allocate v^ with lengths</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top"></td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x<sub>i</sub>: integer type</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">x<sub>0</sub>..x<sub>n</sub></p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">PACK(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">VAR x:REAL; n:INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">pack x and n into x</p>
                  </td>
                </tr>
                <tr>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">UNPK(x, n)</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">VAR x:REAL; VAR n:INTEGER</p>
                  </td>
                  <td class="tableblock halign-left valign-top">
                    <p class="tableblock">unpack x into x and n</p>
                  </td>
                </tr>
              </tbody>
            </table>
            <div class="paragraph">
              <p>The parameter <code>n</code> of PACK represents the exponent of <code>x</code>.
                <code>PACK(x, y)</code> is equivalent to <code>x := x * 2<sup>y</sup></code>.
                UNPK is the reverse operation. The resulting <code>x</code> is normalized,
                such that 1.0 &lt;= x &lt; 2.0.</p>
            </div>
            <div class="paragraph">
              <p>COPY allows the assignment of a string or a CHAR array containing a
                terminating 0X to another CHAR array. If necessary, the assigned
                value is truncated to the target length minus one. The target will
                always contain 0X as a terminator.</p>
            </div>
            <div class="paragraph">
              <p>In <code>ASSERT(x, n)</code> and <code>HALT(n)</code>, the interpretation
                of <code>n</code> is left to the underlying system implementation.</p>
            </div>
            <div class="paragraph">
              <p>The predeclared procedure NEW is used to allocate data blocks in free
                memory. There is, however, no way to explicitly dispose an allocated
                block. Rather, the Oberon+ runtime uses a garbage collector to find
                the blocks that are not used any more and to make them available
                for allocation again. A block is in use as long as it can be reached
                from a global pointer variable via a pointer chain. Cutting this
                chain (e.g., setting a pointer to NIL) makes the block collectable.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_modules">11. Modules</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>A module is a collection of declarations of constants, types, variables,
            and procedures, together with a sequence of statements for the purpose
            of assigning initial values to the variables. A module constitutes a
            text that is compilable as a unit.</p>
        </div>
        <div class="literalblock">
          <div class="title">Syntax:</div>
          <div class="content">
            <pre>module     = MODULE ident [ TypeParams ] [';']
             { ImportList | DeclarationSequence }
	         [ BEGIN StatementSequence ] END ident ['.']
ImportList = IMPORT import { [','] import } [';']
import     = [ ident ':=' ] ImportPath ident [ TypeActuals ]
ImportPath = { ident '.' }</pre>
          </div>
        </div>
        <div class="paragraph">
          <p>The import list specifies the names of the imported modules. If a module
            A is imported by a module M and A exports an identifier <code>x</code>,
            then <code>x</code> is referred to as <code>A.x</code> within M.</p>
        </div>
        <div class="paragraph">
          <p>If A is imported as <code>B := A</code>, the object <code>x</code> must
            be referenced as <code>B.x</code>. This allows short alias names in qualified
            identifiers.</p>
        </div>
        <div class="paragraph">
          <p>In Oberon+ the import can refer to a module by means of a module name optionally
            prefixed with an import path. There is no requirement that the import
            path actually exists in the file system, or that the source files corresponding
            to an import path are in the same file system directory. It is up to
            the compiler how source files are mapped to import paths. An imported
            module with no import path is first looked up in the import path of the
            importing module.</p>
        </div>
        <div class="paragraph">
          <p>A module must not import itself.</p>
        </div>
        <div class="paragraph">
          <p>Identifiers that are to be exported (i.e. that are to be visible in client
            modules) must be marked by an export mark in their declaration (see Chapter
            <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>).</p>
        </div>
        <div class="paragraph">
          <p>The statement sequence following the symbol BEGIN is executed when the
            module is loaded, which is done after the imported modules have been
            loaded. It follows that cyclic import of modules is illegal.</p>
        </div>
        <div id="oberon-2-example" class="listingblock">
          <div class="title">Listing 2. Example with original Oberon-2 syntax</div>
          <div class="content">
            <pre class="highlight"><code class="language-oberon" data-lang="oberon">MODULE Lists;
	IMPORT Out;
    TYPE
        List*    = POINTER TO ListNode;
        ListNode = RECORD
            value : INTEGER;
            next  : List;
        END;

    PROCEDURE (l : List) Add* (v : INTEGER);
    BEGIN
        IF l = NIL THEN
            NEW(l);           (* create record instance *)
            l.value := v
        ELSE
            l.next.Add(v)
        END
    END Add;

    PROCEDURE (t: Tree) Write*;
    BEGIN
    	Out.Int(t.value,8); Out.Ln;
    	IF t.next # NIL THEN t.next.Write END;
    END Write;
END Lists.</code></pre>
          </div>
        </div>
        <div class="listingblock">
          <div class="title">Listing 3. <a href="#oberon-2-example">Same example</a> with syntactic
            simplifications</div>
          <div class="content">
            <pre class="highlight"><code class="language-oberon" data-lang="oberon">module Lists
	import Out
    type
        List*     = ^record
            value : integer
            next  : List
        end

    proc (l : List) Add* (v : integer)
    begin
        if l = nil then
            new(l)           // create record instance
            l.value := v
        else
            l.next.Add(v)
        end
    end Add

    proc (t: Tree) Write*
    begin
    	Out.Int(t.value,8); Out.Ln
    	if t.next # nil then t.next.Write end
    end Write
end Lists</code></pre>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_generics">11.1. Generics</h3>
          <div class="paragraph">
            <p>Oberon+ supports generic programming. Modules can be made generic by
              adding formal type parameters. Generic modules can be instantiated
              with different types which makes it easier to design reusable algorithms
              and data structures. The instantiation of a generic module occurs when
              importing it. A generic module can be instantiated more than one time
              in the same module with different type parameters. See <a href="#_modules">Modules</a></p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>TypeParams       = '&lt;' ident { [','] ident } '&gt;'
TypeActuals      = '&lt;' NamedType { ',' NamedType } '&gt;'
module = MODULE ident [ TypeParams ] [';'] { ImportList | DeclarationSequence }
	[ BEGIN StatementSequence ] END ident ['.']
ImportList = IMPORT import { [','] import } [';']
import = [ ident ':=' ] ImportPath ident [ TypeActuals ]</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>See also <a href="#obx-generics-example">this example</a>.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_definitions">11.2. Definitions</h3>
          <div class="paragraph">
            <p>A DEFINITION is a special kind of MODULE which only includes public declarations.
              The export mark <code>*</code> is redundant, but <code>-</code> can
              be used to mark read-only exports (see <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>).</p>
          </div>
          <div class="paragraph">
            <p>Definitions can be used when the implementation of a module is not available
              or done in another programming language than Oberon+.</p>
          </div>
          <div class="literalblock">
            <div class="title">Syntax:</div>
            <div class="content">
              <pre>definition   = DEFINITION ident [';']  [ ImportList ] declarations END ident ['.']
declarations = { CONST { ConstDeclaration [';'] }
			   | TYPE { TypeDeclaration [';'] }
			   | VAR { VariableDeclaration [';'] }
			   | ProcedureHeading [';'] }</pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_definition_of_terms">Appendix A: Definition of terms</h2>
      <div class="sectionbody">
        <div class="dlist">
          <dl>
            <dt class="hdlist1">Integer types</dt>
            <dd>
              <p>BYTE, SHORTINT, INTEGER, LONGINT</p>
            </dd>
            <dt class="hdlist1">Real types</dt>
            <dd>
              <p>REAL, LONGREAL</p>
            </dd>
            <dt class="hdlist1">Numeric types</dt>
            <dd>
              <p>integer types, real types</p>
            </dd>
            <dt class="hdlist1">Same types</dt>
            <dd>
              <p>Two variables a and b with types T<sub>a</sub> and T<sub>b</sub> are
                of the same type if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are both denoted by the same
                      type identifier, or</p>
                  </li>
                  <li>
                    <p>T<sub>a</sub> is declared to equal T<sub>b</sub> in a type declaration
                      of the form T<sub>a</sub> = T<sub>b</sub>, or</p>
                  </li>
                  <li>
                    <p>a and b appear in the same identifier list in a variable, record
                      field, or formal parameter declaration and are not open arrays.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Equal types</dt>
            <dd>
              <p>Two types T<sub>a</sub> and T<sub>b</sub> are equal if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are the <em>same type</em>, or</p>
                  </li>
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are open array types with <em>equal element types</em>,
                      or</p>
                  </li>
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are procedure types whose formal
                      parameters <em>match</em>, or</p>
                  </li>
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are pointer types with <em>equal</em>                      base types.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Type inclusion</dt>
            <dd>
              <p>Numeric types include (the values of) smaller numeric types. WCHAR
                includes the values of CHAR. See <a href="#type-inclusion-relations">here</a>                for more information.</p>
            </dd>
            <dt class="hdlist1">Type extension (record)</dt>
            <dd>
              <p>Given a type declaration T<sub>b</sub> = RECORD(T<sub>a</sub>)&#8230;&#8203;END,
                T<sub>b</sub> is a direct extension of T<sub>a</sub>, and T<sub>a</sub>                is a direct base type of T<sub>b</sub>. A type T<sub>b</sub> is an
                extension of a type T<sub>a</sub> (T<sub>a</sub> is a base type of
                T<sub>b</sub>) if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>a</sub> and T<sub>b</sub> are the <em>same types</em>,
                      or</p>
                  </li>
                  <li>
                    <p>T<sub>b</sub> is a direct extension of T<sub>a</sub>.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Type extension (pointer)</dt>
            <dd>
              <p>If P<sub>a</sub> = POINTER TO T<sub>a</sub> and P<sub>b</sub> = POINTER
                TO T<sub>b</sub> , P<sub>b</sub> is an extension of P<sub>a</sub>                (P<sub>a</sub> is a base type of P<sub>b</sub>) if T<sub>b</sub>                is an extension of T<sub>a</sub>.</p>
            </dd>
            <dt class="hdlist1">Assignment compatible</dt>
            <dd>
              <p>An expression e of type T<sub>e</sub> is assignment compatible with
                a variable v of type T<sub>v</sub> if one of the following conditions
                hold:</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>e</sub> and T<sub>v</sub> are the <em>same type</em>;</p>
                  </li>
                  <li>
                    <p>T<sub>e</sub> and T<sub>v</sub> are numeric or character types
                      and T<sub>v</sub> <em>includes</em> T<sub>e</sub> <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnote_6" title="View footnote.">6</a>]</sup>;</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is a SET type and T<sub>e</sub> is of INTEGER or
                      smaller type;</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is a BYTE type and T<sub>e</sub> is a Latin-1 character
                      type;</p>
                  </li>
                  <li>
                    <p>T<sub>e</sub> and T<sub>v</sub> are record types and T<sub>e</sub>                      is a <em>type extension</em> of T<sub>v</sub> and the dynamic
                      type of v is T<sub>v</sub>;</p>
                  </li>
                  <li>
                    <p>T<sub>e</sub> and T<sub>v</sub> are pointer types and T<sub>e</sub>                      is a <em>type extension</em> of T<sub>v</sub> or the pointers
                      have <em>equal</em> base types;</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is a pointer or a procedure type and <code>e</code>                      is NIL;</p>
                  </li>
                  <li>
                    <p>T<sub>e</sub> is an open array and T<sub>v</sub> is an array
                      of <em>equal</em> base type;</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is an array of WCHAR, T<sub>e</sub> is a Unicode
                      BMP or Latin-1 string or character array, and STRLEN(e) &lt;
                      LEN(v);</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is an array of CHAR, T<sub>e</sub> is a Latin-1
                      string or character array, and STRLEN(e) &lt; LEN(v);</p>
                  </li>
                  <li>
                    <p>T<sub>v</sub> is a procedure type and <code>e</code> is the name
                      of a procedure whose formal parameters <em>match</em> those
                      of T<sub>v</sub>.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Parameter compatible</dt>
            <dd>
              <p>An actual parameter <code>a</code> of type T<sub>a</sub> is parameter
                compatible with a formal parameter <code>f</code> of type T<sub>f</sub>                if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>f</sub> and T<sub>a</sub> are <em>equal</em> types, or</p>
                  </li>
                  <li>
                    <p><code>f</code> is a value parameter and T<sub>a</sub> is <em>assignment compatible</em>                      with T<sub>f</sub>, or</p>
                  </li>
                  <li>
                    <p><code>f</code> is an IN or VAR parameter T<sub>a</sub> must be
                      the <em>same type</em> as T<sub>f</sub>, or T<sub>f</sub> must
                      be a record type and T<sub>a</sub> an <em>extension</em> of
                      T<sub>f</sub>.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Array compatible</dt>
            <dd>
              <p>An actual parameter <code>a</code> of type T<sub>a</sub> is array compatible
                with a formal parameter <code>f</code> of type T<sub>f</sub> if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>T<sub>f</sub> and T<sub>a</sub> are the <em>equal type</em>,
                      or</p>
                  </li>
                  <li>
                    <p>T<sub>f</sub> is an open array, T<sub>a</sub> is any array, and
                      their element types are <em>array compatible</em>, or</p>
                  </li>
                  <li>
                    <p>T<sub>f</sub> is an open array of CHAR and T<sub>a</sub> is a
                      Latin-1 string, or</p>
                  </li>
                  <li>
                    <p>T<sub>f</sub> is an open array of WCHAR and T<sub>a</sub> is
                      a Unicode BMP or Latin-1 string.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Expression compatible</dt>
            <dd>
              <p>For a given operator, the types of its operands are expression compatible
                if they conform to the following table (which shows also the result
                type of the expression). CHAR and WCHAR arrays that are to be compared
                must contain 0X as a terminator. Type T1 must be an extension of
                type T0:</p>
            </dd>
          </dl>
        </div>
        <table class="tableblock frame-all grid-all spread">
          <colgroup>
            <col style="width: 12.5%;">
            <col style="width: 25%;">
            <col style="width: 25%;">
            <col style="width: 37.5%;">
          </colgroup>
          <thead>
            <tr>
              <th class="tableblock halign-left valign-top">operator</th>
              <th class="tableblock halign-left valign-top">first operand</th>
              <th class="tableblock halign-left valign-top">second operand</th>
              <th class="tableblock halign-left valign-top">result type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">+ - *</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">smallest numeric type including both operands</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">/</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">smallest real type type including both operands</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">+ - * /</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">DIV MOD</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">integer</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">integer</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">smallest integer type type including both operands</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">OR &amp; ~</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">= # &lt;</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">numeric</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">&lt;= &gt; &gt;=</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHAR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHAR</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top"></td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHAR array, string</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">CHAR array, string</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">= #</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top"></td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top"></td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">NIL, pointer type T0 or T1</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">NIL, pointer type T0 or T1</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top"></td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">procedure type T, NIL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">procedure type T, NIL</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">IN</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">integer</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">SET</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
            <tr>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">IS</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">type T0</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">type T1</p>
              </td>
              <td class="tableblock halign-left valign-top">
                <p class="tableblock">BOOLEAN</p>
              </td>
            </tr>
          </tbody>
        </table>
        <div class="dlist">
          <dl>
            <dt class="hdlist1">Matching formal parameter lists</dt>
            <dd>
              <p>Two formal parameter lists match if</p>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>they have the same number of parameters, and</p>
                  </li>
                  <li>
                    <p>parameters at corresponding positions have <em>equal types</em>,
                      and</p>
                  </li>
                  <li>
                    <p>parameters at corresponding positions are both either value,
                      VAR or IN parameters.</p>
                  </li>
                </ol>
              </div>
            </dd>
            <dt class="hdlist1">Matching result types</dt>
            <dd>
              <p>The result types of two procedures match if they are either the <em>same type</em>                or none.</p>
            </dd>
          </dl>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_syntax_of_oberon">Appendix B: Syntax of Oberon+</h2>
      <div class="sectionbody">
        <div class="literalblock">
          <div class="content">
            <pre>Oberon =  module | definition
qualident = [ ident '.' ] ident
identdef = ident [ '*' | '-' ]
ConstDeclaration = identdef '=' ConstExpression
ConstExpression = expression
TypeDeclaration = identdef '=' type
type = NamedType | enumeration
	| ArrayType | RecordType | PointerType | ProcedureType
NamedType = qualident
TypeParams = '&lt;' ident { [','] ident } '&gt;'
TypeActuals = '&lt;' NamedType { ',' NamedType } '&gt;'
enumeration = '('  ident { [','] ident } ')'
ArrayType = ARRAY [ LengthList ] OF type
	 | '[' [ LengthList ] ']' type
LengthList = length {',' length}
length = ConstExpression
RecordType = RECORD ['(' BaseType ')'] [FieldListSequence]  END
BaseType = NamedType
FieldListSequence = FieldList [ ';' ] { FieldList [ ';' ] }
FieldList = IdentList ':' type
IdentList = identdef { [','] identdef}
PointerType = ( POINTER TO | '^' ) type
ProcedureType = ( PROCEDURE | PROC ) [FormalParameters]
VariableDeclaration = IdentList ':' type
designator = qualident {selector}
selector = '.' ident | '[' ExpList ']' | '^' | '(' qualident ')'
ExpList = expression {',' expression}
expression = SimpleExpression [ relation SimpleExpression ]
relation = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN | IS
SimpleExpression = ['+' | '-'] term { AddOperator term }
AddOperator = '+' | '-' | OR
term = factor {MulOperator factor}
MulOperator = '*' | '/' | DIV | MOD | '&amp;'
literal = number | string | hexstring | hexchar | NIL
	| TRUE | FALSE | set
factor = literal
	| designator [ActualParameters]
	| '(' expression ')' | '~' factor
set = '{' [ element {',' element} ] '}'
element = expression ['..' expression]
ActualParameters = '(' [ExpList] ')'
statement = [ assignment | ProcedureCall
	| IfStatement | CaseStatement
	| WithStatement | LoopStatement
	| ExitStatement | ReturnStatement
	| WhileStatement | RepeatStatement | ForStatement ]
assignment = designator ':=' expression
ProcedureCall = designator [ActualParameters]
StatementSequence = statement { [";"] statement}
IfStatement = IF expression THEN StatementSequence
	{ElsifStatement} [ElseStatement] END
ElsifStatement = ELSIF expression THEN StatementSequence
ElseStatement = ELSE StatementSequence
CaseStatement = CASE expression OF Case { '|' Case }
	[ ELSE StatementSequence ] END
Case = [ CaseLabelList ':' StatementSequence ]
CaseLabelList = LabelRange { ',' LabelRange }
LabelRange = label [ '..' label ]
label = ConstExpression
WhileStatement = WHILE expression DO StatementSequence
	{ElsifStatement2} END
ElsifStatement2 = ELSIF expression DO StatementSequence
RepeatStatement = REPEAT StatementSequence UNTIL expression
ForStatement = FOR ident ':=' expression TO expression
	[ BY ConstExpression ] DO StatementSequence END
WithStatement = WITH Guard DO StatementSequence
	{ '|' Guard DO StatementSequence}
	[ ELSE StatementSequence ] END
Guard = qualident ':' qualident
LoopStatement = LOOP StatementSequence END
ExitStatement = EXIT
ProcedureDeclaration = ProcedureHeading [ ';' ]
	ProcedureBody END ident
ProcedureHeading = ( PROCEDURE | PROC ) [Receiver]
	 identdef [ FormalParameters ]
Receiver = '(' [VAR] ident ':' ident ')'
ProcedureBody = DeclarationSequence
	[ BEGIN StatementSequence
	| ReturnStatement [ ';' ] ]
DeclarationSequence =
	{ CONST { ConstDeclaration [';'] }
	| TYPE { TypeDeclaration [';'] }
	| VAR { VariableDeclaration [';'] }
	| ProcedureDeclaration [';'] }
ReturnStatement = RETURN [ expression ]
FormalParameters = '(' [ FPSection { [';'] FPSection } ] ')'
	[ ':' ReturnType ]
ReturnType = NamedType | ( POINTER TO | '^') NamedType
FPSection = [ VAR | IN ] ident { [','] ident } ':' FormalType
FormalType = type
module = MODULE ident [ TypeParams ] [';'] { ImportList | DeclarationSequence }
	[ BEGIN StatementSequence ] END ident ['.']
ImportList = IMPORT import { [','] import } [';']
import = [ ident ':=' ] ImportPath ident [ TypeActuals ]
ImportPath = { ident '.' }
definition = DEFINITION ident [';']  [ ImportList ]
	DeclarationSequence2 END ident ['.']
DeclarationSequence2 =
	{ CONST { ConstDeclaration [';'] }
	| TYPE { TypeDeclaration [';'] }
	| VAR { VariableDeclaration [';'] }
	| ProcedureHeading [';'] }</pre>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_references">Appendix C: References</h2>
      <div class="sectionbody">
        <div class="ulist">
          <ul>
            <li>
              <p>
                <a id="Ada83"></a>[Ada83] ISO 8652:1987 Programming languages — Ada. International
                Organization for Standardization.</p>
            </li>
            <li>
              <p>
                <a id="Mo91"></a>[Mo91] Mössenböck, H.; Wirth, N. (1991). The Programming Language
                Oberon-2. Structured Programming, 12(4):179-195, 1991. <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf"
                  class="bare">http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf</a>                (accessed 2020-11-16).</p>
            </li>
            <li>
              <p>
                <a id="Om01"></a>[Om01] Oberon microsystems, Inc. (2001). Component Pascal Language
                Report. <a href="https://web.archive.org/web/20191021025943/http://www.oberon.ch/pdf/CP-Lang.pdf"
                  class="bare">https://web.archive.org/web/20191021025943/http://www.oberon.ch/pdf/CP-Lang.pdf</a>                (accessed 2021-01-21).</p>
            </li>
            <li>
              <p>
                <a id="Wi16"></a>[Wi16] Wirth, N. (2016). The Programming Language Oberon.
                <a
                  href="https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf"
                  class="bare">https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf</a> (accessed
                  2020-11-16).</p>
            </li>
            <li>
              <p>
                <a id="Wi73"></a>[Wi73] Wirth, N. (1973). The Programming Language Pascal (Revised
                Report). ETH Report. <a href="https://doi.org/10.3929/ethz-a-000814158"
                  class="bare">https://doi.org/10.3929/ethz-a-000814158</a> (accessed
                2020-11-16).</p>
            </li>
            <li>
              <p>
                <a id="Wi87"></a>[Wi87] Wirth, N. (1987). From Modula to Oberon and the programming
                language Oberon. ETH Report. <a href="https://doi.org/10.3929/ethz-a-005363226"
                  class="bare">https://doi.org/10.3929/ethz-a-005363226</a> (accessed
                2020-11-16).</p>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <div id="footnotes">
    <hr>
    <div class="footnote" id="_footnote_1">
      <a href="#_footnoteref_1">1</a>. generic modules, inspired by <a href="#Ada83">[Ada83]</a>
    </div>
    <div class="footnote" id="_footnote_2">
      <a href="#_footnoteref_2">2</a>. subject to basic type differences and limited
      access to objects declared in the environment of nestes procedures
    </div>
    <div class="footnote" id="_footnote_3">
      <a href="#_footnoteref_3">3</a>. this corresponds to the implementation of
      the Blackbox framework 1.7, see <a href="https://blackboxframework.org" class="bare">https://blackboxframework.org</a>      <a href="#Om01">[Om01]</a>
    </div>
    <div class="footnote" id="_footnote_4">
      <a href="#_footnoteref_4">4</a>. adopted from <a href="#Om01">[Om01]</a>
    </div>
    <div class="footnote" id="_footnote_5">
      <a href="#_footnoteref_5">5</a>. this is called <em>covariance</em>, adopted
      with modifications from <a href="#Om01">[Om01]</a>
    </div>
    <div class="footnote" id="_footnote_6">
      <a href="#_footnoteref_6">6</a>. character types include strings with length
      1
    </div>
  </div>
</body>

</html>