/*
* Copyright 2021 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Oberon+ parser/compiler library.
*
* The following is the license that applies to this copy of the
* library. For a license to use the library under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "ObxCGen2.h"
#include "ObxAst.h"
#include "ObErrors.h"
#include "ObxProject.h"
#include <QtDebug>
#include <QFile>
#include <QDir>
#include <QCryptographicHash>
#include <QCoreApplication>
#include <QDateTime>
using namespace Obx;
using namespace Ob;

#ifndef OBX_AST_DECLARE_SET_METATYPE_IN_HEADER
Q_DECLARE_METATYPE( Obx::Literal::SET )
#endif

#define _MY_GENERICS_

struct ObxCGenCollector : public AstVisitor
{
    QList<Procedure*> allProcs;
    QList<Record*> allRecords;
    Module* thisMod;

    void collect(Type* t)
    {
        switch( t->getTag() )
        {
        case Thing::T_Array:
            collect(cast<Array*>(t)->d_type.data());
            break;
        case Thing::T_Record:
            {
                Record* r = cast<Record*>(t);
                allRecords.append( r );
                foreach( const Ref<Field>& f, r->d_fields )
                {
                    collect(f->d_type.data());
                }
                if( r->d_base )
                    collect(r->d_base.data());
            }
            break;
        case Thing::T_Pointer:
            collect(cast<Pointer*>(t)->d_to.data());
            break;
        case Thing::T_ProcType:
            {
                ProcType* pt = cast<ProcType*>(t);
                foreach( const Ref<Parameter>& p, pt->d_formals )
                    collect(p->d_type.data());
                if( pt->d_return )
                    collect(pt->d_return.data());
            }
            break;
        case Thing::T_QualiType:
            break;
        }
    }

    void collect( Named* n )
    {
        switch( n->getTag() )
        {
        case Thing::T_Procedure:
            {
                Procedure* p = cast<Procedure*>(n);
                allProcs.append(cast<Procedure*>(n));
                p->accept(this);
            }
            break;
        case Thing::T_NamedType:
            collect(n->d_type.data());
            break;
        case Thing::T_Variable:
        case Thing::T_Parameter:
        case Thing::T_LocalVar:
            collect(n->d_type.data());
            break;
        }
    }

    void visit( Module* me )
    {
        thisMod = me;
        foreach( const Ref<Named>& n, me->d_order )
            collect(n.data());
    }

    void visit( Procedure* me)
    {
        foreach( const Ref<Named>& n, me->d_order )
            collect(n.data());
    }
};

struct ObxCGenImp : public AstVisitor
{
    Errors* err;
    Module* thisMod;
    int level;
    QTextStream h,b;
    bool ownsErr;
    bool debug; // generate line pragmas
    quint32 anonymousDeclNr; // starts with one, zero is an invalid slot

    ObxCGenImp():err(0),thisMod(0),ownsErr(false),level(0),debug(false),anonymousDeclNr(1){}

    inline QByteArray ws() { return QByteArray(level*4,' '); }

    static QByteArray escape(const QByteArray& str)
    {
        return str; // TODO avoid collision with C keywords
    }

    static void dedication(QTextStream& out)
    {
        out << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() << " on "
               << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;
    }

    static inline Type* derefed( Type* t )
    {
        if( t )
            return t->derefed();
        else
            return 0;
    }

    QByteArray dottedName( Named* n, bool withModule = true )
    {
        // concatenate names up to but not including module
        QByteArray name = n->d_name; // TODO: check escape is done by callers
        Named* scope = n->d_scope;
        if( n->getTag() == Thing::T_Procedure )
        {
            Procedure* proc = cast<Procedure*>(n);
            if( proc->d_receiverRec )
            {
                // if the scope is a bound proc follow its receiver, but first use the proc name.
                // this is necessary because procs bound to different recs can have the same name and
                // even have the same name as ordinary procs, so there is a risk of duplicate names when
                // just following the normal scope
                scope = proc->d_receiverRec->findDecl();
                Q_ASSERT( scope );
            }
        }
        if( scope )
        {
            const int tag = scope->getTag();
            if( tag != Thing::T_Module )
            {
                return dottedName(scope) + "$" + name;
            }else if( withModule )
                return moduleRef(cast<Module*>(scope)) + "$" + name;
        }
        return name;
    }

    static QByteArray moduleRef(Module* m)
    {
        QByteArray name = m->d_fullName.join('$');
        if( !m->d_metaActuals.isEmpty() )
        {
            QCryptographicHash hash(QCryptographicHash::Md5);
            hash.addData(m->formatMetaActuals());
            name += "$" + hash.result().toHex();
        }
        return escape(name);
    }

    QByteArray classRef( Named* className )
    {
        Q_ASSERT( className && className->getTag() == Thing::T_NamedType );
        Module* m = className->getModule();
        return /* moduleRef(m) + "$" + */ dottedName(className); // dotted because also records nested in procs are lifted to module level
    }

    QByteArray classRef( Record* r )
    {
        Named* n = r->findDecl();
        if( n && n->getTag() == Thing::T_NamedType )
            return classRef(n);
        else
        {
#ifdef _DEBUG
            Q_ASSERT( r->d_slotValid );
#endif
            if( n == 0 )
                n = r->findDecl(true);
            Module* m = n ? n->getModule() : 0;
            if( m == 0 )
                m = thisMod;
            return moduleRef(m) + "$" + QByteArray::number(r->d_slot);
        }
    }

    static inline bool passByRef( Parameter* p )
    {
        return p->d_var;
    }

    QByteArray formatFormals( ProcType* pt, bool withName = true, Parameter* receiver = 0 )
    {
        QByteArray res = "(";
        if( receiver )
        {
#if 0
            Type* t = receiver->d_type.data();
            Pointer p;
            if( passByRef(receiver) )
            {
                t = &p;
                p.d_to = receiver->d_type.data();
                p.d_decl = receiver;
                p.d_loc = receiver->d_loc;
            }
            res += formatType( t, withName ? escape(receiver->d_name) : "" );
#else
            res += "void*" + ( withName ? " " + escape(receiver->d_name) : "" );
#endif
        }
        for( int i = 0; i < pt->d_formals.size(); i++ )
        {
            if( i != 0 || receiver )
                res += ", ";
            Type* t = pt->d_formals[i]->d_type.data();
            Pointer p;
            if( passByRef(pt->d_formals[i].data()) )
            {
                t = &p;
                p.d_to = pt->d_formals[i]->d_type.data();
                p.d_decl = pt->d_formals[i].data();
                p.d_loc = pt->d_formals[i]->d_loc;
            }
            res += formatType( t, withName ? escape(pt->d_formals[i]->d_name) : "" );
        }
        if( pt->d_varargs )
        {
            if( !pt->d_formals.isEmpty() )
                res += ", ";
            res += "...";
        }
        res += ")";
        return res;
    }

    inline static QByteArray formatBaseType(int t)
    {
        switch( t )
        {
        case Type::BYTE:
        case Type::BOOLEAN:
            return "uint8_t";
        case Type::CHAR:
            return "char";
        case Type::WCHAR:
            return "uint16_t";
        case Type::SHORTINT:
            return "int16_t";
        case Type::INTEGER:
            return "int32_t";
        case Type::LONGINT:
            return "int64_t";
        case Type::REAL:
            return "float";
        case Type::LONGREAL:
            return "double";
        case Type::SET:
            return "uint32_t";
        case Type::CVOID:
            return "void";
        default:
            return "?basetype?";
        }
    }

    QByteArray formatType( Type* t, const QByteArray& name = QByteArray() )
    {
        if( t == 0 )
            return "void" + ( !name.isEmpty() ? " " + name : "" );
        switch(t->getTag())
        {
        case Thing::T_Array:
            {
                Array* a = cast<Array*>(t);
                if( a->d_type.isNull() )
                    return QByteArray(); // already reported

                QByteArray res;
                if( a->d_lenExpr.isNull() )
                    res = "*" + ( !name.isEmpty() ? " " + name : "" );
                else
                {
                    res = name;
                    res += "[";
                    res += QByteArray::number(a->d_len);
                    res += "]";
                }
                return formatType( a->d_type.data(), res );
            }
            break;
        case Thing::T_BaseType:
            return formatBaseType(t->getBaseType()) + ( !name.isEmpty() ? " " + name : "" );
        case Thing::T_Enumeration:
            return "int" + ( !name.isEmpty() ? " " + name : "" );
        case Thing::T_Pointer:
            {
                Pointer* me = cast<Pointer*>(t);
                if( me->d_to.isNull() )
                    break;

                QByteArray res = "*" + ( !name.isEmpty() ? " " + name : "" );
                Type* td = derefed(me->d_to.data());
                if( td && td->getTag() == Thing::T_Array && !td->d_unsafe )
                {
                    return formatType( cast<Array*>(td)->d_type.data(), res );
                }
                // else
                return formatType( me->d_to.data(), res );
            }
            break;
        case Thing::T_ProcType:
            {
                ProcType* pt = cast<ProcType*>(t);
                const QByteArray returnType = formatType(pt->d_return.data());
                return returnType + " (*" + name + ")" + formatFormals(pt); // name can legally be empty
            }
            break;
        case Thing::T_QualiType:
            {
                QualiType* me = cast<QualiType*>(t);
#if 0
                Named* n = me->d_quali->getIdent();
                if( n )
                {
                    Module* m = n->getModule();
                    if( m )
                        return moduleRef(m) + "$" + dottedName(n);
                    else
                        return formatType(n->d_type.data());
                }else
                    return "???";
#else
                return formatType(me->d_quali->d_type.data(),name);
#endif
            }
            break;
        case Thing::T_Record:
            return ( t->d_union ? "union " : "struct " ) +
                    classRef(cast<Record*>(t)) + ( !name.isEmpty() ? " " + name : "" );
        default:
            Q_ASSERT(false);
        }
        return "?type?" + ( !name.isEmpty() ? " " + name : "" );
    }

    void allocRecordDecl(Record* r)
    {
        if( r->d_slotValid )
            return; // can happen e.g. with VAR foo, bar: RECORD ch: CHAR; i: INTEGER END;
        Named* n = r->findDecl();
        if( n == 0 || n->getTag() != Thing::T_NamedType )
        {
            r->d_slot = anonymousDeclNr++;
            r->d_slotValid = true;
        }
    }

    void emitRecordDecl(Record* r)
    {
        if( r->d_slotAllocated )
            return;
        r->d_slotAllocated = true;

        const QByteArray className = classRef(r);
        h << ws() << "struct " << className << "$Class$;" << endl;
        h << ws() << "struct " << className << " {" << endl;
        level++;

        if( !r->d_unsafe )
            h << ws() << "struct " << className << "$Class$* class$;" << endl;

        QList<Field*> fields = r->getOrderedFields();

        foreach( Field* f, fields )
            f->accept(this);

        level--;
        h << "};" << endl << endl;
    }

    void emitClassDecl(Record* r)
    {
        if( r->d_unsafe )
            return;

        const QByteArray className = classRef(r);

        h << ws() << "struct " << className << "$Class$ {" << endl;
        b << ws() << "struct " << className << "$Class$ " << className << "$class$ = { " << endl;
        level++;

        if( r->d_baseRec )
            h << ws() << "struct " << classRef(r->d_baseRec) << "$Class$* super$;" << endl;
        else
            h << ws() << "void* super$;" << endl;

        if( r->d_baseRec )
            b << ws() << "&" << classRef(r->d_baseRec) << "$class$," << endl;
        else
            b << ws() << "0," << endl;

        QList<Procedure*> mm = r->getOrderedMethods();
        foreach( Procedure* m, mm )
        {
            ProcType* pt = m->getProcType();

            QByteArray name = escape(m->d_name);
            name = "(*" + name + ")";
            name += formatFormals(pt,true,m->d_receiver.data());
            name = formatType(pt->d_return.data(), name);
            h << ws() << name << ";" << endl;

            name = dottedName(m);
            b << ws() << name << "," << endl;
        }

        level--;
        b << "};" << endl << endl;
        h << "};" << endl;
        h << "struct " << className << "$Class$ " << className << "$class$;" << endl << endl;
    }

    void visit( Module* me)
    {
        const QByteArray name = moduleRef(me);
        h << "#ifndef _" << name.toUpper() << "_" << endl;
        h << "#define _" << name.toUpper() << "_" << endl << endl;

        dedication(h);

        h << "#include <stdint.h>" << endl;
        h << "#include <stddef.h>" << endl;

        dedication(b);
        b << "#include \"" << thisMod->getName() << ".h\"" << endl << endl;

        ObxCGenCollector co;
        me->accept(&co);

        foreach( Import* imp, me->d_imports )
        {
            if(imp->d_mod->d_synthetic )
                continue; // ignore SYSTEM
            h << "#include \"" << imp->d_mod->getName() << ".h\"" << endl;
            if( !imp->d_mod.isNull() && !imp->d_mod->d_metaActuals.isEmpty() )
            {
                for( int i = 0; i < imp->d_mod->d_metaActuals.size(); i++ )
                {
                    Type* at = imp->d_mod->d_metaActuals[i].data();
                    //Q_ASSERT( !at->d_slotValid );
                    at->d_slot = i;
                    at->d_slotValid = true;
                    at->d_metaActual = true;
                }
            }
        }
        h << endl;
        h << "// Declaration of module " << me->getName() << endl << endl;

        if( !Record::calcDependencyOrder(co.allRecords).isEmpty() )
            err->error(Errors::Generator, thisMod->d_file, 1,1, // shouldn't acutally happen since caught by validator
                         "circular record by value dependencies are not supported by C");

        foreach( Record* r, co.allRecords )
            allocRecordDecl(r);

        foreach( Record* r, co.allRecords )
            emitRecordDecl(r);

        foreach( const Ref<Named>& n, me->d_order )
        {
            if( n->getTag() == Thing::T_Variable )
                n->accept(this);
        }

        foreach( Procedure* p, co.allProcs )
            p->accept(this);

        foreach( Record* r, co.allRecords )
            emitClassDecl(r);

        h << "void " << name << "$init$(void);" << endl;
        b << "static int initDone$ = 0;" << endl;
        b << "void " << name << "$init$(void) {" << endl;

        level++;
        foreach( const Ref<Named>& n, me->d_order )
        {
            if( n->getTag() == Thing::T_Variable )
                ; // TODO emitInitializer(n.data());
        }
        b << ws() << "if(initDone$) return; else initDone$ = 1;" << endl;
#if 0 // done in init literal
        foreach( Record* r, co.allRecords )
        {
            if( r->d_baseRec )
                b << ws() << classRef(r) << "$class$.super$ = &" << classRef(r->d_baseRec) << "$class$;" << endl;
        }
#endif

        foreach( const Ref<Statement>& s, me->d_body )
        {
            s->accept(this);
        }
        level--;

        b << "}" << endl;

        h << "#endif" << endl;
    }

    void visit( Field* me)
    {
        h << ws() << formatType(me->d_type.data(), escape(me->d_name) ) << ";" << endl;
    }

    void visit( Variable* me )
    {
        h << ws() << "extern " << formatType(me->d_type.data(), moduleRef(thisMod)+"$"+me->d_name ) << ";" << endl;
        b << ws() << formatType(me->d_type.data(), moduleRef(thisMod)+"$"+me->d_name ) << ";" << endl;
    }

    void visit( Procedure* me)
    {
        ProcType* pt = me->getProcType();
        QByteArray name = /* moduleRef(thisMod) + "$" + */ dottedName(me);
        name += formatFormals(pt,true,me->d_receiver.data());
        name = formatType(pt->d_return.data(), name);

        h << name << ";" << endl;

        b << name << " {" << endl;
        level++;
        foreach( const Ref<Named>& n, me->d_order )
        {
            if( n->getTag() == Thing::T_LocalVar )
            {
                b << ws() << formatType( n->d_type.data(), escape(n->d_name) ) << ";" << endl;
                // TODO: initializer
            }
        }

        foreach( const Ref<Statement>& s, me->d_body )
        {
            s->accept(this);
        }

        level--;
        b << "}" << endl << endl;
    }

    void visit( LocalVar* ) {}


    void visit( NamedType* ) {}
    void visit( Const* ) {}
    void visit( Import* ) {}
    void visit( BuiltIn* ) {}
    void visit( Call* ) {}
    void visit( Return* ) {}
    void visit( Assign* ) {}
    void visit( IfLoop* ) {}
    void visit( ForLoop* ) {}
    void visit( CaseStmt* ) {}
    void visit( Literal* ) {}
    void visit( SetExpr* ) {}
    void visit( IdentLeaf* ) {}
    void visit( UnExpr* ) {}
    void visit( IdentSel* ) {}
    void visit( ArgExpr* ) {}
    void visit( BinExpr* ) {}
    void visit( GenericName* ) {}
    void visit( Exit* ) {}

    void visit( Array* )
    {
        Q_ASSERT(false);
        /*
            arrays or pointer to arrays can be the types of fields, variables, locals and parameters.
            in general taking the address of an array is not supported, but with VAR/IN params an implicit
            address is handed into the procedure; it still cannot be converted to a pointer though.
            in contrast arrays can be dynamically created, even with a length not known at compile time.
            we need a way to transport the dim/size of an array with the pointer. it's inefficient to explicitly
            store these data with value arrays where it is known at compile time and invariant. with open
            arrays (or VAR/IN parameter) it is unavoidable though. If we add this information to the array object
            we obviously need two types of array objects, one with and one without dim/size information.
            A possible solution is to add dim/size information to the pointer/var param value. the dim number
            and type doens't change and is always known at compile time; so the pointer/var param could look
            e.g. like struct { uint32_t $0; void* $a; } or struct { uint32_t $0,$1; void* $a; } etc.
            if this information is in the array object instead we get a problem when passing either a value array
            (which has no size info) or a dereferenced array pointer (whose object has size info) is passed
            to a var parameter (the body of the proc has no clue which kind was passed).
        */
    }
    void visit( Pointer* ) { Q_ASSERT(false); }
    void visit( Record* ) { Q_ASSERT(false); }
    void visit( ProcType* ) { Q_ASSERT(false); }
    void visit( QualiType* ) { Q_ASSERT(false); }
    void visit( Enumeration* ) { Q_ASSERT(false); }
    void visit( Parameter* ) { Q_ASSERT(false); }
    void visit( BaseType* ) { Q_ASSERT(false); }

};

static bool copyLib( const QDir& outDir, const QByteArray& name, QTextStream* cout )
{
#if 0 // TODO
    QFile f( QString(":/scripts/Dll/%1.dll" ).arg(name.constData() ) );
    if( !f.open(QIODevice::ReadOnly) )
    {
        qCritical() << "unknown lib" << name;
        return false;
    }
    QFile out( outDir.absoluteFilePath(name + ".dll") );
    if( !out.open(QIODevice::WriteOnly) )
    {
        qCritical() << "cannot open for writing" << out.fileName();
        return false;
    }
    out.write( f.readAll() );
    if( cout )
        *cout << "rm \"" << name << ".dll\"" << endl;
#endif
    return true;
}

bool Obx::CGen2::translateAll(Obx::Project* pro, bool debug, const QString& where)
{
    Q_ASSERT( pro );
    if( where.isEmpty() )
    {
        qCritical() << "translateAll requires a path";
        return false;
    }

    QDir outDir(where);

    QByteArray buildStr;
    QTextStream bout(&buildStr);
    QByteArray clearStr;
    QTextStream cout(&clearStr);

    QList<Module*> mods = pro->getModulesToGenerate();
    const quint32 errCount = pro->getErrs()->getErrCount();
    QSet<Module*> generated;
    foreach( Module* m, mods )
    {
        if( m->d_synthetic )
            ; // NOP
        else if( m->d_hasErrors )
        {
            qDebug() << "terminating because of errors in" << m->d_name;
            return false;
        }else if( m->d_isDef
#ifdef _OBX_USE_NEW_FFI_
                  && !m->d_externC
#endif
                  )
        {
            // NOP
        }else
        {
            if( m->d_metaParams.isEmpty() )
            {
                QList<Module*> result;
                m->findAllInstances(result);
                result.append(m);
                foreach( Module* inst, result )
                {
                    if( !generated.contains(inst) )
                    {
                        generated.insert(inst);
                        QFile b(outDir.absoluteFilePath(inst->getName() + ".c"));
                        if( b.open(QIODevice::WriteOnly) )
                        {
                            QFile h(outDir.absoluteFilePath(inst->getName() + ".h"));
                            if( h.open(QIODevice::WriteOnly) )
                            {
                                //qDebug() << "generating C for" << m->getName() << "to" << f.fileName();
                                if( !CGen2::translate(&h, &b, inst,debug,pro->getErrs()) )
                                {
                                    qCritical() << "error generating C for" << inst->getName();
                                    return false;
                                }
                                bout << "./ilasm /dll " << "\"" << inst->getName() << ".il\"" << endl;
                                cout << "rm \"" << inst->getName() << ".il\"" << endl;
                                cout << "rm \"" << inst->getName() << ".dll\"" << endl;
                            }else
                                qCritical() << "could not open for writing" << h.fileName();
                        }else
                            qCritical() << "could not open for writing" << b.fileName();
                    }
                }
            }
        }
    }
    if( !mods.isEmpty() )
    {
        const QByteArray name = "main$";
        QByteArrayList roots;
        for(int i = mods.size() - 1; i >= 0; i-- )
        {
            if( mods[i]->d_usedBy.isEmpty() )
                roots.append(mods[i]->getName());
        }
        if( roots.isEmpty() )
            roots.append(mods.last()->getName()); // shouldn't actually happenk

        QFile f(outDir.absoluteFilePath(name + ".c"));
        if( f.open(QIODevice::WriteOnly) )
        {
            const Project::ModProc& mp = pro->getMain();
            if( mp.first.isEmpty() )
                CGen2::generateMain(&f,roots);
            else
                CGen2::generateMain(&f,mp.first, mp.second);
            bout << "cc /exe " << "\"" << name << ".c\"" << endl;
            cout << "rm \"" << name << ".c\"" << endl;
            cout << "rm \"" << name << ".o\"" << endl;
        }else
            qCritical() << "could not open for writing" << f.fileName();
    }

    const bool log = true;
    if( pro->useBuiltInOakwood() ) // TODO
    {
        copyLib(outDir,"In",log?&cout:0);
        copyLib(outDir,"Out",log?&cout:0);
        copyLib(outDir,"Files",log?&cout:0);
        copyLib(outDir,"Input",log?&cout:0);
        copyLib(outDir,"Math",log?&cout:0);
        copyLib(outDir,"MathL",log?&cout:0);
        copyLib(outDir,"Strings",log?&cout:0);
        copyLib(outDir,"Coroutines",log?&cout:0);
        copyLib(outDir,"XYplane",log?&cout:0);
    }
    copyLib(outDir,"OBX.Runtime",log ? &cout : 0);

    bout.flush();
    cout.flush();

    QFile build( outDir.absoluteFilePath( "build.sh" ) );
    if( !build.open(QIODevice::WriteOnly) )
    {
        qCritical() << "could not open for writing" << build.fileName();
        return false;
    }else
        build.write(buildStr);
    QFile clear( outDir.absoluteFilePath( "clean.sh" ) );
    if( !clear.open(QIODevice::WriteOnly) )
    {
        qCritical() << "could not open for writing" << clear.fileName();
        return false;
    }else
        clear.write(clearStr);
    const bool ok = pro->getErrs()->getErrCount() == errCount;
    return ok;
}

bool Obx::CGen2::translate(QIODevice* header, QIODevice* body, Obx::Module* m, bool debug, Ob::Errors* errs)
{
    Q_ASSERT( m != 0 && header != 0 && body != 0 );

    if( m->d_hasErrors || !m->d_isValidated ) //  not validated can happen if imports cannot be resolved
        return false;

    if( m->d_isDef && !m->d_externC )
        return true;

    ObxCGenImp imp;
    imp.thisMod = m;
    //imp.emitter = e;
    imp.debug = debug;
    imp.h.setDevice(header);
    imp.b.setDevice(body);

    if( errs == 0 )
    {
        imp.err = new Errors();
        imp.err->setReportToConsole(true);
        imp.ownsErr = true;
    }else
    {
        imp.err = errs;
        imp.ownsErr = false;
    }
    const quint32 errCount = imp.err->getErrCount();


    bool ok = true;
    try
    {
        m->accept(&imp);
        ok = imp.err->getErrCount() == errCount;
    }catch(...)
    {
        ok = false;
    }

    if( imp.ownsErr )
        delete imp.err;

    return ok;
}

bool CGen2::generateMain(QIODevice* to, const QByteArray& callMod, const QByteArray& callFunc)
{
    if( callMod.isEmpty() )
        return false;

    QTextStream out(to);
    ObxCGenImp::dedication(out);

    //out << "#include \"OBX$Runtime.h\"" << endl;
    out << "#include \"" << callMod << ".h\"" << endl << endl;

    out << "int main(void) {" << endl;
    out << "    " << callMod + "init$();" << endl;
    if( !callFunc.isEmpty() )
        out << "    " << callMod + "$" + callFunc + "();" << endl;
    out << "    return 0;" << endl;
    out << "}" << endl;
    return true;
}

bool CGen2::generateMain(QIODevice* to, const QByteArrayList& callMods)
{
    Q_ASSERT( to );
    if( callMods.isEmpty() )
        return false;

    QTextStream out(to);
    ObxCGenImp::dedication(out);

    //out << "#include \"OBX$Runtime.h\"" << endl;
    foreach( const QByteArray& mod, callMods )
        out << "#include \"" << mod << ".h\"" << endl;
    out << endl;

    out << "int main(void) {" << endl;

    foreach( const QByteArray& mod, callMods )
    {
        out << "    " << mod + "$init$();" << endl;
    }
    out << "    return 0;" << endl;
    out << "}" << endl;
    return true;
    return true;
}
